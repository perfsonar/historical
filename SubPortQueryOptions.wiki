<wiki:toc max_depth="6" />

== Introduction ==

Current design of metadata elements (in particular network interface descriptions, end point pairs) do not lend to easy separation namely because all necessary knowledge of these topology units are known at creation time.  For instance a layer 3 interface contains:

 * _*Host Name*_ - Name of the host that can be contacted to find this interface
 * _*Interface Address*_ - address (physical, ip) of this interface
 * _*IP Address*_ - Management address of the network device for this interface
 * _*Interface Name*_ - Name of this interface
 * _*Interface Description*_ - Description of this interface

Most (if not all) of these are known at creation time.  Dynamic components, such as Layer 2 VLANs, almost always involve splicing together information from other components, namely interfaces at higher levels that span multiple domains.  The following work discuses issues in the construction of these formats as well as reconciliation internal to the topology service.  Query format is mentioned in particular, as finding all information is a crucial problem.  

== Problem Description ==

The interest is being able to query specific sub-ports on a switch.  For
example, allowing a client to query for vlan 3000 on port so-0/0/0 or a
port using timeslots 3-6 on optical port 1-A-1-1.

The topology description for this host would look like:

{{{
<nmtb:node id="urn:nml:internet2.edu:node_packrat">
  <nmtb:name>packrat</nmtb:name>
  <nmtb:address type="ipv4">207.75.164.10</nmtb:address>
</nmtb:node>

<ethernet:port id="urn:nml:internet2.edu:port_packrat_eth0">
  <ethernet:relation type="parent">urn:nml:internet2.edu:port_packrat_eth0</ethernet:relation>
  <ethernet:name>eth0</ethernet:name>
</ethernet:port>

<ethernet:port id="urn:nml:internet2.edu:port_packrat_eth0.3000">
  <ethernet:relation type="shares">urn:nml:internet2.edu:port_packrat_eth0</ethernet:relation>
  <ethernet:vlan>3000</ethernet:vlan>
</ethernet:port>

}}}

Using the topology description given above, there doesn't seem to be a way to
easily and unambiguously query for "vlan 3000 on port eth0" using the metadata
xpath pattern matching mechanisms we use.

The only way to even construct that query would require restructuring the
listed metadata. If we nested the elements, we could again use xpath queries.

{{{
<nmtb:node id="urn:nml:internet2.edu:node_packrat">
  <nmtb:name>packrat</nmtb:name>
  <nmtb:address type="ipv4">207.75.164.10</nmtb:address>

  <ethernet:port id="urn:nml:internet2.edu:port_packrat_eth0">
    <ethernet:relation type="parent">urn:nml:internet2.edu:port_packrat_eth0</ethernet:relation>
    <ethernet:name>eth0</ethernet:name>
    <ethernet:port id="urn:nml:internet2.edu:port_packrat_eth0.3000">
      <ethernet:relation type="shares">urn:nml:internet2.edu:port_packrat_eth0</ethernet:relation>
      <ethernet:vlan>3000</ethernet:vlan>
    </ethernet:port>
  </ethernet:port>
</nmtb:node>
}}}

The xpath would look something like:
{{{
//nmtb:node[nmtb:address='207.75.164.10' and ethernet:port/ethernet:name='eth0' and ethernet:port/ethernet:port/ethernet:vlan='3000'];
}}}

However, this has an ambiguity to it. Say that a given eventType is applicable
at multiple levels. For example, you can grab TL1 alarms for a given host, or
just for a given port.

When the host is specified, the xpath would look like:

{{{
//nmtb:node[nmtb:address='207.75.164.10'];
}}}

When the metadata database was queried, this would return the node, along with
all the elements contained within it. The open question would be, which element
did they mean to grab? It would need some way of signifying "i wanted to grab
element X or elements of type X that match my query". 

== Possible Query Options ==

There are three possible options to handle query operations:

 * [SubPortQueryOptions#Merged_Metadata_Approach Merged Metadata Approach]
 * [SubPortQueryOptions#Modified_XPath_Style Modified XPath Style]
 * [SubPortQueryOptions#More_complex_querying_methods More complex querying methods]
 * [SubPortQueryOptions#Crazy_Approach Crazy Approach]

=== Merged Metadata Approach ===

The way that the 'interface' subjects get around this issue is that they have a single metadata containing all the relevant elements.

{{{
<nmwgt:interface>
  <nmwgt:ipAddress type="ipv4">10.10.11.1</nmwgt:ipAddress>
  <nmwgt:hostName>dreadnought</nmwgt:hostName>
  <nmwgt:ifName>eth0</nmwgt:ifName>
  <nmwgt:ifDescription>gigE</nmwgt:ifDescription>
  <nmwgt:ifAddress type="ipv4">128.4.133.163</nmwgt:ifAddress>
  <nmwgt:ifIndex>0</nmwgt:ifIndex>
  <nmwgt:type>eth0</nmwgt:type>
</nmwgt:interface>
}}}

This has the two levels (node and port) merged into one metadata element. This same approach could be tried for the elements listed above:

{{{
<nmtb:port id="urn:nml:internet2.edu:port_packrat_eth0.3000">
  <nmtb:name>packrat</nmtb:name> 
  <nmtb:address type="ipv4">207.75.164.10</nmtb:address> 
  <nmtb:name>eth0</nmtb:name>
  <nmtb:vlan>3000</nmtb:vlan>
</nmtb:port>
}}}

The downsides to this approach:
  * Element confusion: This has two 'name' elements, one of which isn't the name of the port. It could get even wierder if addresses were added in since that port would have two addresses (the management address for packrat and the specific interface address).
  * Namespaces: The above has everything as nmtb (polluting its namespace), we could also selectively have elements be in one topology namespace or the other, though it wouldn't fix the problem above.
  * Ambiguity: If the query is done as an XPath, a request for the trunk port would also match any vlan ports allocated.
  * Client Output: The merged port couldn't be returned as is to the client since since the result may not make sense (which name is correct? which capacity is correct?).

=== Modified XPath Style ====

Another way around that would be to have the client specify an empty element at a given depth to request all the elements at that depth.

For example, to return all the trunk ethernet port elements, the client would use:

{{{
<nmtb:node>
  <nmtb:address>207.75.164.10</nmtb:address>
  <ethernet:port />
</nmtb:node>
}}}

To match all the VLANs, the client would do:

{{{
<nmtb:node>
  <nmtb:address>207.75.164.10</nmtb:address>
  <ethernet:port>
    <ethernet:port />
  </ethernet:port>
</nmtb:node>
}}}

There are a couple downsides to this approach.

  * The service needs to know more about the metadata it's querying against since it would need to parse the subject to ascertain what level of depth it should be returning.
  * The metadata output could get rather large if every element was returned with full instances of all its parent elements. The other option is to return every "element" separately, which is what the E2EMon style does.
  * It moves away from the "relation" style of linking network elements together

=== More complex querying methods ===

Another option would be to allow client queries to include relation elements.

{{{
<nmtb:node id="1">
  <nmtb:address>207.75.164.10</nmtb:address>
</nmtb:node>

<ethernet:port id="2">
  <ethernet:relation type="parent">1</ethernet:relation>
</ethernet:port>

<ethernet:port>
  <ethernet:relation type="shares">2</ethernet:relation>
</ethernet:port>
</nmtb:node>
}}}

This fits better with the keeping the relation elements separate, and in
theory, we could start doing a single metadata per element, and reducing the
duplication. Each of those elements above, for instance, could be in its own
metadata. (Starting to sound like E2EMon...)

The downsides to this approach:

  * The service needs to know even more about elements since it'll need to go through all the metadata looking for the matching elements. 
  * Querying is notedly harder since the identifiers given by the user are not "real" identifiers, so we'll need to map those to the identifiers in the backend.

=== Crazy Approach ===

Punt the issue. Get rid of all the topology elements in the MAs, and only have them in the Topology Services. The client would query the topology service (using any complex query it desires), and then looks up which MAs contain data on the topology identifiers it gets back.

Personally, I like this approach the best. However, this would have substantial inertia problems as the model is notedly different than what we're used to.

== Last Modified ==

$Id$
