#summary Instructions for Deploying the perfSONAR-PS Status Service

=Status Service Overview=
The perfSONAR project has developed infrastructure that enables clients to check on the status of circuits as they pass over a given domain.

The perfSONAR end-to-end status monitoring infrastructure involves three pieces: a status collector, a status database and a services that aggregates the distributed status information and makes it available.

Each domain is in charge of monitoring the circuit segments in its domain. To do this, the domains deploy a status collector and a status database.

The status collector is a daemon that periodically polls the status of a link. It can use scripts or SNMP to obtain the actual link status. It stores the link status into the status database.

The status database is a SQL database that stores the status of links or circuits. This status information is made available using the perfSONAR protocols.

E2EMon is a system that generates a webpage describing the status of end-to-end circuits. It is configured to consult a set of status databases, one for each domain. The software then constructs a webpage describing the status of all the circuits it finds in the status databases.

=Installation=

The perfSONAR Status service may be installed in one of the following ways:
  * Standalone RPM
  * CPAN
  * SVN

We will explain nuances of each of these installation methods.

==Standalone RPM==

This RPM package includes the perfSONAR-PS Status software compiled as a binary executable. The benefit to this particular installation method is that there are no additional download and installation requirements (beyond the database) that are necessary. As it is a binary executable, it may not work everywhere. The current RPM is compiled with RHEL v4 and v5 systems on a 32 bit processor in mind. Future releases will address other OS and Architecture considerations.

===Installation===

You can download the RPM for RHEL4 [here|^perfSONAR_PS-Status-0.09-1.i386.fc4.rpm].

The RPM for RHEL5 is coming soon.

Once downloaded, you can use the rpm program to install the package by running the command "rpm -ivh perfSONAR_PS-Status-0.09-1.i386.rh4.rpm".

The files will be installed in /opt/perfsonar.

===Configuration===

The perfSONAR Status binary RPM contains two command line configuration scripts that will prompt the user with questions to configure the daemons. The tool to configure the collector daemon is "psConfigureLinkStatusCollector" and the tool to configure the service daemon is "psConfigureLinkStatus". Both scripts will be located in /opt/perfsonar/bin.

Configuring the actual elements to be monitored and the E2EMon specifics can be in later sections.

===Starting The Daemon===

Once configured, you can run the command "/etc/init.d/perfsonar-linkstatus start" to start the perfSONAR Status daemon. You can start the collector by running "/etc/init.d/perfsonar-linkstatus-collector start".

==CPAN==

It is recommended that you use the above RPMs instead of the CPAN packages for now as the CPAN packages do not yet support the E2EMon compatibility.

===Installation===

CPAN offers the next best thing to a binary executable: management of all related perl libraries in an automated installation system.  To install via CPAN:
  # On your system, type 'cpan', you may need to be root or use 'sudo' to do this.
  # If this is your first time using CPAN, there may be configuration questions to answer.  Do these to the best of your ability.
  # You should see a prompt: '_cpan>_'
  # Type: install perfSONAR_PS::Services::MA::Status
  # Answer any necessary questions
  # Type: install perfSONAR_PS::Collectors::LinkStatus
  # Type exit

Be aware of any errors during installation. The most common issue is the use of XML::LibXML.  If installation fails and you are filing a bug report, please include as much of the installation log as possible.

The files will be installed in the standard system locations(/usr/bin, /usr/lib/perl5, etc).

===Configuration===

====Command Line Tool====

The perfSONAR Status CPAN package contains two command line configuration scripts that will prompt the user with questions to configure the daemons. The tool to configure the collector daemon is "psConfigureCollectors" and the tool to configure the service daemon is "psConfigureDaemon". Both scripts will be located in /usr/bin.

Configuring the actual elements to be monitored and the E2EMon specifics can be in later sections.

===Starting The Daemon===

After configuration has been completed, the service daemon can be started by running the command "/etc/init.d/perfsonar start". The collector daemon can be started by running the command "/etc/init.d/perfsonar-collector start".

==SVN==

Checkout the read-only version of our SVN repository:
  * svn checkout [http://anonsvn.internet2.edu/svn/perfSONAR-PS/trunk/]

===Configuration===

The perfSONAR Status subversion package contains two command line configuration scripts that will prompt the user with questions to configure the daemons. The tool to configure the collector daemon is "psConfigureCollectors" and the tool to configure the service daemon is "psConfigureDaemon". Both scripts will be located in the directory where you checked out the subversion repository.

===Starting The Daemon===

After configuration, you can start the service daemon by running the "perfsonar-daemon.pl" script in the directory where you checked out the subversion repository. The collector daemon can be started by running the "perfsonar-collector.pl" script in the same directory.

==Initializing The Database==

Utility scripts can be downloaded to initialize the database.

===SQLite===

Download this [script|^db-sqlite.sql] and run:

  * sqlite3 /tmp/status.db < db-sqlite.sql

===MySQL===

====Create User and Database====

Download this [script|^db-mysql.sql], replace 'CHANGE--------ME' to the status db account password and in case of MySQL run:

  * mysql -u root -p'<root_pass>' < db-mysql.sql


==Example Configuration==
There are some examples files that show a common configuration. In this configuration, there is a single circuit passing over the Internet2 domain. This circuit uses a script to measure status of the circuit segment as it crosses the domain and uses SNMP to measure the status of the ingress/egress points of the circuit. Also included is a configuration file to enable E2EMon services to retrieve information about the circuit as it passes over the Internet2 domain.

[^elements.conf] is used to tell the collector how to measure the circuit
[^e2emon_compat.conf] is used to create the elements expected by E2EMon corresponding to the measured circuit
[^example_script.pl] is an example script that will randomly generate an administrative or operational status

==Configuring which elements to monitor==

The elements.conf file is used to specify which network elements, link or circuit segment, the collector daemon should be monitoring.  The core structures in the elements.conf file are elements and agents. The elements define the network element whose status is being monitored, and the agents define how the status of the element is collected. The file consists of a series of element structures defining each of the elements to monitor.

The element structures consist of three aspects: a knowledge level, a set of one or more identifiers and a set of agents.

The knowledge property is an attribute of the "element" XML element. It is used to define the certainty with which is to defining the "true" status of the element, and can be one of two values "full" and "partial". For example, a bidirectional link being measured by the collector may only be able to check the status of one side of the link. In this case, the knowledge level would be "partial". If a unidirectional link were being monitored, the knowledge level would be "full".


{{{
<element knowledge="full">
...
</element>
}}}

Each element being monitored has one or more id elements. Each of these elements consists of the URN identifier for the element being monitored. If the element being monitored has more than one identifier associated with it, multiple id attributes can be included.

{{{
<element knowledge="full">
  <id>urn:ogf:network:domain=internet2.edu:path=DRAGON_dcn.internet2.edu_384943</id>
  <id>urn:ogf:network:domain=internet2.edu:link=Link_From_Hous_To_Losa</id>
  <id>urn:ogf:network:domain=internet2.edu:node=rtr.hous:port=eth0:link=Link_From_Hous_To_Losa</id>
  <id>urn:ogf:network:domain=internet2.edu:node=rtr.losa:port=eth0:link=Link_From_Hous_To_Losa</id>
  ...
</element>
}}}

Each element may have one or more agents which obtain part of the status information about the element. If the element were a bidirectional link, it might contain an agent to measure the status on one side of the link, and an agent to measure the status on the other side. If the element were a circuit, it would include agents to measure every segment of the circuit.  Each element must have a minimum of two agents, one to grab the administrative status for the element and one to grab the operational status for the element.There are two different agent types: operational and administrative. This can be specified with the status_type attribute on the agent XML element.

There are three different approaches to status collection: constants, scripts and SNMP polling. To specify which type of collection the agent should perform, the type can be set to "constant", "script" or "snmp".

The constant agent simply returns a constant value whenever it is polled. This can be used to fudge a certain status type if you are unable to obtain the actual status or the actual status does not exist for that kind of element. The contents of the agent XML element must be a single XML element named constant. The contents of this XML element is the constant value to return.

{{{
<agent type="constant" status_type="oper">
  <constant>normaloperation</constant>
</agent>
}}}

The script agent is given a script to run to poll the status of an element. The script name is given in a script_name XML element containing the script name.  You can specify parameters to pass to the script using an script_parameters XML element.

The output of the specified script must be of the form "`[timestamp],[status]`". The first argument passed to the script will be the type of status being requested "admin" or "oper". Subsequent parameters will consist of any parameters specified.

{{{
<agent type="script" status_type="oper">
  <script_name>/home/aaron/scripts/ciena_status.pl</script_name>
  <script_paramters>10.0.0.1 1-A-1-1</script_paramters>
</agent>
}}}

The above script would be called like "/home/aaron/scripts/ciena_status.pl oper 10.0.0.1 1-A-1-1".

The snmp agent will query a router using SNMP to grab the status of an interface. You must include a hostname XML element which contains the hostname or ip address of the SNMP server. You must also specify a version element specifying which SNMP version to use. A community element must be included specifying the community string for the router. An ifName or ifIndex may be included as well. If an ifName is specified, on startup, the collector will find the ifIndex corresponding to that ifName.

{{{
<agent type="snmp" status_type="oper">
  <hostname>192.168.10.1</hostname>
  <version>2c</version>
  <community>password</community>
  <ifName>eth0</ifName>
</agent>
}}}

By default, the collector will use its local time to specify when the element had the retrieved status. However, you can specify a primary_time_source attribute with a value of "1" to say that the time retrieved from that agent should be used instead of the collectors local time.

{{{
<agent type="snmp" status_type="oper" primary_time_source="1">
  ...
</agent>
}}}

==Configuring for E2EMon Compatibility==

The e2emon_links.conf file is used to specify the link and node definitions required by E2EMon clients. In this file, logical links will be defined using the elements in the measurement archives. The core structures in the e2emon_links.conf file are nodes, circuits and a domain.



Every E2EMon compatible service must tell the client which domain it is in. The selection of the appropriate domain name is outside of the scope of the document. Once selected though, include a domain XML element containing the domain name in the configuration file.


In E2EMon, circuit segments connect node elements, which may correspond to physical or logical nodes. You can define these node elements by including one or more node XML elements.

Each of these node XML elements must have a name attribute containing the name of the node element. Since other domains will need to know the node names to construct interdomain links, the construction of these names is outside the scope of this document.

Each node XML element may have any of the following optional child elements.

  * institution - The organization who controls this node
  * city - The city in which the node is located
  * country - The country in which the node is located
  * latitude - The latitude at which the node is located
  * longitude - The longitude at which the node is located

{{{
<node name="RTRHOUS" />

<node name="RTRSALT">
  <city>Salt Lake City</city>
  <country>USA</country>
</node>

<node name="RTRCHIC">
  <latitude>41.90</latitude>
  <longitude>87.65</longitude>
</node>
}}}
          
The nodes in E2EMon are connected by links. A link can correspond to a single physical bidirectional link, or a series of physical links. In the configuration file, each E2EMon link is described by a link XML element.  

         
In E2EMon, a link can have two names: a global name describing the end-to-end circuit and a local name describing the name of that domain's segment of the end-to-end circuit. The global name must be agreed upon by every domain the circuit passes over and its select is out of the scope of this document. Once selected, the global name can be specified using globalName XML element. The localName is similar, being specified with a localName XML element.   

         
The E2EMon link will be constructed out of one or more network elements from the measurement archive. These elements can be specified using segmentID XML elements. Each of these XML elements must contain the URN identifier described above for the network element. The status for the E2EMon link will be the combined status of all the segments specified.

         
Each E2EMon link has nodes, as described above, at either end.  The link XML elements contain pointers to the two nodes.  These pointers are represented as endpoint XML elements.  Each endpoint XML element contains two attributes, "type" and "name". The name attribute specifies the name of the node. The type describes the role of this node in the end-to-end circuit. It can either be the end of the circuit, in which case the value will be endpoint, or it can be a demarcation point between links, in which case the value will be demarcpoint.


The knowledge property is an attribute of the link XML element. It is used to define the certainty with which is to defining the "true" status of the link, and can be one of two values "full" and "partial". For example, a bidirectional link being measured by the collector may only be able to check the status of one side of the link. In this case, the knowledge level would be "partial". If the domain were monitoring both sides of the link, the knowledge level would be "full".

{{{
<link knowledge="full">
  <segmentID>urn:ogf:network:domain=internet2:node=rtr.atla:port=eth0:link=Link_To_Losa</segmentID>
  <segmentID>urn:ogf:network:domain=internet2:node=rtr.losa:port=eth0:link=Link_To_Atla</segmentID>
  <globalName>SOMEPROJECT-INTERNET2-ESNET-001</globalName>
  <localName>INTERNET2-LOSA-ATLA</localName>
  <endpoint type="endpoint" name="RTRATLA" />
  <endpoint type="demarcpoint" name="RTRLOSA" />
</link>
}}}

