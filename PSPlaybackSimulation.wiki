#description of perfSONAR playback simulator.

<wiki:toc max_depth="6" />

= Introduction =

This simulator helps in playing requests collected from a lookup service to another lookup service. This is very helpful in a scenarios were testing of requests from real world is needed without affecting the running infrastructure. Also, this simulator gives the user the control of the simulation time where it can be real time simulation in which the requests are sent on the same speed received on the instrumented lookup service.

=Terms=
  * Instrumented lookup service: This is a lookup service in production environment where every request and result is being logged by netlogger.
  * Request: any request is being sent to the lookup service including Echo, Register, and Query requests.
  * Simulation Target: is the lookup service were all requests from the instrumented lookup service will be sent to.

=Instrumentation=

The changes needed to the current netlogger version is very minor. Only two changes are needed on Request.pm to log the incoming request text and the result text for that query.

The following change were made at Request.pm *This might need to be removed once committed to the svn*

  * This line:

{{{my $nlmsg = perfSONAR_PS::Utils::NetLogger::format( "org.perfSONAR.Request.clientRequest.start", { remotehost => $self->{CALL}->peerhost(), } ); }}} 

was changed to:

{{{my $nlmsg = perfSONAR_PS::Utils::NetLogger::format( "org.perfSONAR.Request.clientRequest.start", { remotehost => $self->{CALL}->peerhost(), rawInput => join(' ', split(' ', $self->getRawRequestAsString)), } );}}}

  * And this line:

{{{my $nlmsg = perfSONAR_PS::Utils::NetLogger::format( "org.perfSONAR.Request.clientRequest.end" );}}}

was changed to:
    
{{{my $nlmsg = perfSONAR_PS::Utils::NetLogger::format( "org.perfSONAR.Request.clientRequest.end", {rawOutput => join(' ', split(' ', $self->getResponse)), });}}}

= How the simulator works =

This is just playback of events collected from netlogger to a different target. This simulator is designed to multi-threaded to allow it to simulate more than request concurrently as possible. But caution should be taken, this simulator run only on one machine and there are two primary limits; maximum number of running threads and maximum number of TCP connections.

The simulator starts by starting a thread _log_reader_ which reads the log file and put the jobs on dispatch queue. It's is important to note that logs are can be nested on the log file; that means we can have multiple start events before seeing the end events. To address this, a temporary hash is used by this thread to save the start event data (time stamp and request). Also a temporary FIFO is used to keep the order of the events to make sure that request 1 is enqueued on the dispatch queue before request 2 even if request 2 end event is before request 1. Once the start event and the end event is read, the job is submitted to the dispatch queue. It's clear from this design that the dispatch queue in most cases is slower that the log reading thread which might end filling the dispatch queue with too many jobs and running out of memory. Thus, two variables are used to control the behavior of the _read log_ thread. These variables are _max_dispatch_queue_ and _max_read_wait_. The _max_dispatch_queue_ is a limit for the maximum dispatch queue once reached by the read log thread it will sleep for _max_read_wait_ until there is space available on the dispatch queue.

The second thread is the _dispatcher_. The main function for this thread is to dequeue elements from the dispatch queue and then create new send request thread for each job to handle the job. This thread also keeps notion of the simulation and real time. Simulation time original time recorded on the log file. Real time is the current time of the machine running the simulation. Basically, it will issue new send request thread whenever _(delta real time `*` simulation speed >= delta simulation time)_; where delta is _(the time of the current event â€“ the time of the previous event)_. The two major things that control the behavior of this thread are _simulation_speed_ and _max_threads_. For each new send request thread, the _current_threads_ is incremented by one and it will be decremented once the thread finish executing. If the _current_threads_ reaches _max_threads_ the _dispatcher_ will stop issuing new send requests until one of the current running requests ends. Usually we want _max_threads_ to be large to get more throughput but having large number may just kill the machine and we will start to get inaccurate results, so this parameter is very dependent on the simulation hardware capabilities.

The third thread is the _send_request_ (actually there more than one thread running of this thread type). This thread is created by the _dispatcher_ for each request. This will take the request and use _perfSONAR_PS::Transport_ to send the request to the target of the simulation. Once the request is served this thread will kill itself. Note this thread is detached after it started for better performance.

The forth thread is the _log_writer_ thread. In this simulator none of the threads expect the main thread are suppose to write any output to a file nor to the screen. If any thread want to log something it will enqueue it on the _log_queue_ and this thread will constantly check it. This thread will run forever until it receives a log of type _ENDOFSIMULATION_. It is important to mention that this thread will not exit once it receives _ENDOFSIMULATION_, rather it will set an internal flag and wait for all threads of type _send_request_ to finish and then it will exit.

=Running the simulator=
_TODO_

=TODO List=
  # Allow user to control different simulation variables like _max_threads_ and _max_read_wait_ from the command line. Currently a hard coded variables are used to do that but it would be nice if the user can override these settings.
  # Logging to netlogger. Currently the _log_write_ thread just print out the logs but it can be easily converted to write logs using netlogger.
  # Compare results from the simulation target with the results from the instrumented service. This might involve using some XPATH because some fields like IDes can change but the results are the same.
== Last Updated ==

$Id$