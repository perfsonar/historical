<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://docbook.org/xml/4.2/docbookx.dtd">
<article>

  <articleinfo>
    <title>dLS Implementation Phase 1 -- The Rise of the gLS</title>
    
    <authorgroup>
      <author>
        <firstname>J.</firstname>
        <surname>Boote</surname>
      </author>

      <author>
        <firstname>M.</firstname>
        <surname>Glowiak</surname>
      </author>
   
      <author>
        <firstname>M.</firstname>
        <surname>Swany</surname>
      </author>
    
      <author>
        <firstname>J.</firstname>
        <surname>Zurawski</surname>
      </author>
    </authorgroup>

  </articleinfo>

  <section id="changes" xreflabel="Document Changes">
    <title>Document Changes</title>

    <table frame="all" align="center" halign="center" width="80%"  id="table.1">
      <title>Change Log</title>
      <tgroup cols="1" align="left" colsep="1" rowsep="1">
        <colspec colnum="1" colname="c1" width="10%"/>
        <colspec colnum="2" colname="c2" width="10%"/>
        <colspec colnum="3" colname="c3" width="50%"/>
        <colspec colnum="4" colname="c4" width="30%"/>
        <thead>
          <row>
            <entry>Version</entry>
            <entry>Date</entry>
            <entry>Description</entry>
            <entry>Author(s)</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>1.0</entry>
            <entry>05/2/2007</entry>
            <entry>Initial Preparation</entry>
            <entry>J. Zurawski</entry>
          </row>
          <row>
            <entry>1.01</entry>
            <entry>05/6/2007</entry>
            <entry>Corrections, API Details</entry>
            <entry>J. Zurawski</entry>
          </row>
          <row>
            <entry>1.02</entry>
            <entry>05/7/2007</entry>
            <entry>Implementation Details</entry>
            <entry>J. Zurawski</entry>
          </row>
          <row>
            <entry>1.03</entry>
            <entry>05/8/2007</entry>
            <entry>Plural results/eventType version numbers corrections.</entry>
            <entry>J. Boote</entry>
          </row>
          <row>
            <entry>1.04</entry>
            <entry>05/8/2007</entry>
            <entry>...</entry>
            <entry>J. Zurawski</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
   
  </section>
  
  <section id="introduction" xreflabel="Introduction">
    <title>Introduction</title>
    
    <para>
      This document builds upon the work described in <citation>dLS</citation>
      to create <command>Phase 1</command> of the proposed distributed
      information service.  This document will describe concrete details of the
      plan, prescribing both the overall structure of the system as well as
      associated APIs used to interact.
    </para>
    
    <para>
      This work was broken into two phases due to:
    </para>
    
    <para>
      <itemizedlist mark='opencircle'>
        <listitem>
          <para><command>Complexity</command> - The design of a distributed
          information model consists of many considerations and complexities
          to be weighed.  A proper implementation takes time to implement and
          test.</para>
        </listitem>
        <listitem>
          <para><command>Time Constraints</command> -
          <emphasis>perfSONAR</emphasis> has been without a truly global method
          of discovery for some time.  This feature is desperately needed to
          claim full multi-domain operation.</para>
        </listitem>
      </itemizedlist>
    </para>
    
    <para>
      <command>Phase 1</command> of the <emphasis>dLS</emphasis> will be
      followed by <command>Phase 2</command>, a completely distributed Lookup
      Service, sometime in the near future.  Details such as API will not be
      affected by the implementation of <command>Phase 2</command> as it is
      concerned more with the hierarchy of information services and not the
      actual location of the information.
    </para>
        
    <para>
      The remainder of the document is structured as follows:
      <xref linkend="architecture" /> will go into details of the system as
      viewed from afar.  Issues such as communication and individual service
      behavior will be discussed.  <xref linkend="api" /> will describe the
      interface service developers will implement to interact with this system.
      <xref linkend="operation" /> will lay out some common use cases and
      examples.  <xref linkend="implementation" /> will discuss some 
      algorithms and specific considerations that the both reference
      implementations will need to take into account.  Finally 
      <xref linkend="appendix" /> details some XML and code examples to be used
      in the construction of this service.
    </para>
    
  </section>

  <section id="architecture" xreflabel="Architecture">
    <title>Architecture</title>
    
    <para>
      The following schematic shows the overall architecture of this system.
    </para>

    <para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/architecture.png"/>
        </imageobject>
      </mediaobject>
    </para>   

    <para>
      We will now explain some key features of this architecture:
    </para>

    <para>
      <orderedlist numeration="arabic">
        <listitem>
          <para><xref linkend="gLS_instances" /> - Global,
          <emphasis>well known</emphasis>, LS instances that will serve as
          the <emphasis>top level</emphasis> of the hierarchy.  Under normal
          conditions <command>only</command> manage the registration of
          <emphasis>hLS</emphasis> instances and not other forms of
          <emphasis>perfSONAR</emphasis> service.</para>
        </listitem>
        <listitem>
          <para><xref linkend="bootstrapping" /> - Finding gLS instances can
          be challenging, and we <emphasis>should not</emphasis> rely only on
          well known values.  We propose a simple method for this implementation
          phase that will allow other <emphasis>gLS</emphasis> instances, 
          <emphasis>hLS</emphasis>s, and anyone using the API a chance to
          find and communicate with root <emphasis>gLS</emphasis> instances.
          </para>
        </listitem>
        <listitem>
          <para><xref linkend="synchronization" /> - To ease the burden of
          discovery, the top level <emphasis>gLS</emphasis> instances should
          regularly synchronize their summary sets to ensure that any discovery
          query posed anywhere in the framework can be answered correctly.
          </para>
        </listitem>
        <listitem>
          <para><xref linkend="hLS_instances" /> - Local LS instances that
          manage the registration of individual services and communicate a
          summary of information to the upper level.</para>
        </listitem>
        <listitem>
          <para><xref linkend="registration" /> - Services may require
          modifications to support interaction with more than one LS instance to
          foster both reliability and balancing of load.
          </para>
        </listitem>
        <listitem>
          <para><xref linkend="interaction" /> - To use this new framework, 
          clients and services require a unified access method.  This access
          requires two components: Discovery (e.g. <emphasis>where</emphasis>
          information can be found) and Query (e.g. <emphasis>what</emphasis>
          specifically can I find).</para>
        </listitem>
      </orderedlist>
    </para>

    <section id="gLS_instances" xreflabel="gLS Instances">
      <title>gLS Instances</title>
    
      <para>
        The <emphasis>perfSONAR</emphasis> project partners (e.g.
        <citation>ESnet</citation>, <citation>Geant2</citation>,
        <citation>Internet2</citation>, and <citation>RNP</citation>) are
        expected to stand up and maintain <emphasis>root</emphasis>
        <xref linkend="gLS" /> instances.  As the driving force behind
        <emphasis>perfSONAR</emphasis>, this contribution serves as the basis
        for all distributed information discovery.  The purpose of these LS
        instances is similar to the function of the DNS root servers: well known
        contact points to manage data distribution.  With this easily remembered
        location, administrators of new LS instances can easily determine who
        is <emphasis>closest</emphasis> (geographically, topologically, or
        administratively) and use the respective root server (or servers) as a
        registration point.
      </para>

      <para>
        The following image describes the general operation of a
        <emphasis>gLS</emphasis> in the context of other
        <emphasis>gLS</emphasis> instances, <emphasis>hLS</emphasis> instances, 
        and other services.
      </para>

      <para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/gLS.png"/>
          </imageobject>
        </mediaobject>
      </para>   
      
      <para>
        Each well known instance will manage a given set of
        <emphasis>hLS</emphasis> data.  For each <emphasis>gLS</emphasis>,
        maintaining a consistent view of all data contained in the framework
        is necessary to facilitate information discovery.  Service and client
        applications will rely on <emphasis>gLS</emphasis> root servers as a
        point of contact with regards to locating information; therefore each 
        root should know the complete contents at any given time.  To accomplish
        the goals of <emphasis>gLS</emphasis> discovery we rely on some
        <xref linkend="bootstrapping" /> techniques that allow service and
        client applications alike the ability to access the
        <emphasis>upper layer</emphasis> consisting of <emphasis>gLS</emphasis>
        deployments.  To ensure that <emphasis>gLS</emphasis> instances can talk
        an additional data <xref linkend="synchronization" /> step is also
        required.
      </para>        

      <para>        
        The <xref linkend="bootstrapping" /> and
        <xref linkend="synchronization" /> ensure that a
        <emphasis>Discovery</emphasis> query posed to any root is able to be
        completed.  In addition to the process to propagate registration
        information the <emphasis>hLS</emphasis> instances may register
        themselves with multiple <emphasis>gLS</emphasis>s when applicable.
        Due to concerns of policy, load, or latency, this approach may turn out
        to not be very prudent.
      </para>
    
      <para>
        All <emphasis>Discovery</emphasis> queries must originate at the root
        <emphasis>gLS</emphasis> instances if they have any hope of finding
        something globally.  <emphasis>hLS</emphasis> instances may be aware of
        their own summary information and could of course service a discovery
        query posed to them, but the answer will not be relevant.
      </para>
    
      <para>
        <emphasis>gLS</emphasis> instances <command>should not</command> allow
        services beyond <emphasis>hLS</emphasis>s to register with them.  This
        can be an internal mechanism, or could be via a different type of
        registration message.  If services do register with a
        <emphasis>gLS</emphasis> it is understood that they may be left out of
        any summarization and discovery activities (unless the
        <emphasis>gLS</emphasis> summarizes itself, and is able to include this
        information in the discovery phase).  
      </para>
    
    </section>

    <section id="bootstrapping" xreflabel="Bootstrapping">
      <title>Bootstrapping</title>
    
      <para>
        The deployment locations of the <emphasis>gLS</emphasis> may be broadly
        known, but the specific contact information will probably not be.  It
        will be necessary for the <emphasis>gLS</emphasis> instances,
        <emphasis>hLS</emphasis> instances, and the Discovery API to have
        knowledge of the current <emphasis>gLS</emphasis> locations.  The
        following image describes typical bootstrapping issues:
      </para>

      <para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/boot.png"/>
          </imageobject>
        </mediaobject>
      </para> 
      
      <para>       
        The proposed solution for this phase of implementation is to rely upon
        an <emphasis>out of band</emphasis> registration for
        <emphasis>gLS</emphasis> location.  This can proceed in different
        (perhaps simultaneous) ways:
      </para>

      <para>
        <itemizedlist mark='opencircle'>
          <listitem><para><command>Roots File</command> - Similar to a
          <command>root.hints</command> in <emphasis>DNS</emphasis>, we simply
          require a way to find the contact information of root
          <emphasis>gLS</emphasis> instances.  This information could be on a
          web server or a wiki.</para>
          </listitem>
          <listitem><para><command>Meta LS</command> - A deployment of the LS
          code (possibly at ls.perfsonar.net) could be used just for
          <emphasis>gLS</emphasis> registration and location by all interested
          parties.  This service should be modified to ensure it functions only
          for this specific task.</para>
          </listitem>
          <listitem><para><command>CNAMEing Services</command> - The various
          <emphasis>gLS</emphasis> operators may choose to implement DNS
          <emphasis>CNAME</emphasis> aliases to the location of the LS.  This
          will ensure that the location name will always be the same no matter
          where a deployment moves.</para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        It is expected that the first option will be implemented immediately,
        with the prospects of the second option to follow.  The third option
        will be depend on participation from the perfSONAR partners.
      </para>
    
    </section>

    <section id="synchronization" xreflabel="Synchronization">
      <title>Synchronization</title>

      <para>
        There are two possible approaches to information discovery using the 
        <emphasis>gLS</emphasis> deployment scenario.
      </para>

      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <para>
              Client applications consult the <emphasis>Root.hints</emphasis>
              file to find list of <command>all</command>
              <emphasis>gLS</emphasis> instances.  Query each one to find
              complete discovery of the framework.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis>gLS</emphasis> instances periodically exchange
              information via a scheduled or on-demand synchronization
              procedure.  Client applications then pose discovery queries to
              single instance from <emphasis>Root.hints</emphasis> list.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        To ease the communication burden system wide (e.g. every client
        performing discovery to every root causes unnecessary data exchange) the
        second option shall be implemented.  Consider the following simple
        diagram of synchronization:
      </para>

      <para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/sync.png"/>
          </imageobject>
        </mediaobject>
      </para> 

      <para>
        Open questions remain if this should be a periodic scheduled event that
        is frequent enough to capture new information propagation without
        overloading <emphasis>gLS</emphasis> instances or if it may be able to
        function as an on-demand service when new summarizations are available.
      </para>
      
      <para>
        See <xref linkend="appendix_synch" /> for an example of a naive
        synchronization between LS instances.
      </para>

    </section>
    
    <section id="hLS_instances" xreflabel="hLS Instances">
      <title>hLS Instances</title>

      <para>
        This service resembles the current LS implementation.  Aside from the
        changes that allow the <emphasis>hLS</emphasis> itself to register with
        a <emphasis>gLS</emphasis> and the addition of the API, there is little
        difference.  The following diagram discusses some of the major functions
        of the <emphasis>hLS</emphasis> in the context of other services and
        the <emphasis>gLS</emphasis>.
      </para>
        
      <para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/hLS.png"/>
          </imageobject>
        </mediaobject>
      </para>          
      
      <para>
        The <emphasis>hLS</emphasis> will accept registration from any and all
        interested <emphasis>perfSONAR</emphasis> services with the caveat that
        they be from the managed domain (this is not a strict requirement, but
        is logical from both an administrative and functional standpoint).  This
        service <command>should not</command> allow other
        <emphasis>hLS</emphasis> instances to register with it unless it happens
        to be a <emphasis>gLS</emphasis>.  This service still contain the
        primitives of previous the previous LS with regards to query and
        registration and will implement the new API.
      </para>
    
      <para>
        The <emphasis>hLS</emphasis> instances <emphasis>should</emphasis> know
        about at least one <emphasis>gLS</emphasis> instance to register with
        (can be programmed through configuration, or can be gleaned from the 
        <emphasis>Root.hints</emphasis> file and various performance tests to
        find the closest).  Optionally, <emphasis>hLS</emphasis> instances could
        register with as many <emphasis>gLS</emphasis>s as possible. This may
        become complicated due to performance issues (latency, topology) or
        administrative issues (authorization, information sharing).
      </para>

      <para>
        The <emphasis>hLS</emphasis> must summarize the current data set it
        maintains in the following ways:
      </para>

      <para>
        <itemizedlist mark='opencircle'>
          <listitem><para><command>IP Addresses</command> - The IP Addresses of
            all topology elements (for now IPv4, in the future IPv6) must be
            combined into useful CIDR style summaries.  Preliminary work will
            incorporate the <emphasis>Patricia Trie</emphasis> data structure to
            naively find <emphasis>K Dominators</emphasis> from a list of
            addresses.</para>
          </listitem>
          <listitem>
            <para><command>Host/Domain Names</command> - Similar to IP
            Addresses, the hostname of each service will be extracted and
            broken into sub elements (e.g.
            <emphasis>stout.pc.cis.udel.edu</emphasis> is really an
            <emphasis>edu</emphasis>, a <emphasis>udel.edu</emphasis> a
            <emphasis>cis.udel.edu</emphasis> and finally a
            <emphasis>pc.cis.udel.edu</emphasis>). </para>
          </listitem>
          <listitem>
            <para><command>EventTypes</command> - The registered eventType of
            each data for a particular service should be extracted for future
            search and associated to the previous two items.  For instance we
            may have the eventType
            <emphasis>http://ggf.org/ns/nmwg/characteristic/utilization/2.0</emphasis>
            for several interfaces in <emphasis>udel.edu</emphasis> and
            <emphasis>edu</emphasis> but not <emphasis>cis.udel.edu</emphasis>,
            a different eventType may be available in other Domain and Address
            ranges as well.  The <emphasis>gLS</emphasis> will require each
            <emphasis>hLS</emphasis> to organize these in the summary message it
            registers.  The eventType should be associated with both the Domain
            level and IP Address level summarizations.</para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        Another optional behavior is the notion of
        <emphasis>self registration</emphasis>, e.g. making an internal summary
        available to service <emphasis>Discovery</emphasis> requests.  This can
        be as simple as always maintaining an internal view of your summary
        (eliminating the need to register with yourself) or treating the
        <emphasis>hLS</emphasis> instance itself as a <emphasis>root</emphasis>
        <emphasis>gLS</emphasis>.  Either solution delivers the same goal, and
        due to code reuse it is understood that any given deployment may be a
        <emphasis>gLS</emphasis> or <emphasis>hLS</emphasis> so the necessary
        tooling to do either approach would be available.
      </para>

    </section>

    <section id="registration" xreflabel="Multiple Registration">
      <title>Multiple Registration</title>

      <para>
        The following diagram illustrates the procedure of an
        <emphasis>hLS</emphasis> instance registering with two distinct
        <emphasis>gLS</emphasis> instances.
      </para>

      <para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/registration.png"/>
          </imageobject>
        </mediaobject>
      </para>  
    
      <para>
        There are several positive reasons to implement this scheme:
      </para>

      <para>
        <itemizedlist mark='opencircle'>
          <listitem><para><command>Replication</command> - An
          <emphasis>hLS</emphasis> that registers with (and knows about)
          multiple <emphasis>gLS</emphasis> instances is less susceptible to
          being partitioned from the rest of the <emphasis>perfSONAR</emphasis>
          infrastructure.</para>
          </listitem>
          <listitem><para><command>Data Availability</command> - Registration
          on the part of the <emphasis>hLS</emphasis> ensures that data
          summaries are available faster to the <emphasis>gLS</emphasis>.</para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        Several negative reasons also exist.
      </para>

      <para>
        <itemizedlist mark='opencircle'>
          <listitem><para><command>Performance</command> - registering with
          remote <emphasis>gLS</emphasis> instances as well as multiple
          <emphasis>gLS</emphasis>s takes time and effort on the part of the 
          <emphasis>hLS</emphasis>.</para>
          </listitem>
          <listitem><para><command>Complexity</command> - currently the
          <emphasis>gLS</emphasis> instances are <emphasis>well known</emphasis>
          and there is no automatic way to retrieve this result.  Configuring
          many must be done by hand.</para>
          </listitem>
          <listitem><para><command>Duplication</command> - Information in the
          discovery phase will produce duplicate results.</para>
          </listitem>
        </itemizedlist>
      </para>
    
      <para>
        We leave the option of multiple registration up to the individual
        service designers.
      </para>
    
    </section>

    <section id="interaction" xreflabel="Interaction">
      <title>Interaction</title>
      
      <para>
        Currently, services and clients only have a single way to query an 
        <emphasis>LS</emphasis> instance for data: <citation>XQuery</citation>
        or <citation>XPath</citation> statements.  While useful to individuals
        with an intimate knowledge of the data storage structure and the query
        language syntax, this leaves other services and client applications 
        frustrated and out of luck when it comes to lookup.
      </para>
      
      <para>
        As a part of <command>Phase 1</command>, an API for use in client
        applications and other services will be defined.  The following image
        describes the basic operation of the API in terms of services, 
        <emphasis>gLS</emphasis> instances, <emphasis>hLS</emphasis> instances, 
        and clients:
      </para>

      <para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/api.png"/>
          </imageobject>
        </mediaobject>
      </para>  
    
      <para>
        The overall goal of the API should be to abstract away the specifics
        regarding discovery and query from the service and client applications.
        In general these applications will not care about
        <emphasis>how</emphasis> the information is structured but will care
        about if the information exists and where it may be available.  The API
        will address two primary issues:
      </para>

      <para>
        <itemizedlist mark='opencircle'>
          <listitem><para><command>Discovery</command> - Discovery queries have
          known values (e.g. they pertain to a specific domain, address range,
          or eventType) and the end result should be
          <emphasis>locations</emphasis> where a more exact
          <emphasis>query</emphasis> should be sent.</para>
          </listitem>
          <listitem><para><command>Query</command> - more interested in 
          <emphasis>what</emphasis> then <emphasis>where</emphasis>.  These can
          still be <emphasis>XQuery</emphasis> and <emphasis>XPath</emphasis>
          based although they are more at home dealing with domain, address
          range, eventType, or other specific features that pertain to the
          data and service type.</para>
          </listitem>
        </itemizedlist>
      </para>
    
      <para>
        The API will be specified in <xref linkend="api" />.
      </para>
     
    </section>

  </section>
  
  <section id="api" xreflabel="API">
    <title>API</title>
    
    <para>
      To effectively navigate through the distributed information service, an
      effective and complete API is necessary.  This API should offer ways to 
      perform two important tasks (together, and separately as needed):
    </para>

    <para>
      <itemizedlist mark='opencircle'>
        <listitem>
          <para>
            <command>Discovery</command> - A series of parameters should deliver
            results that locate information stored at the
            <emphasis>hLS</emphasis> layer, but reported to and discovered in
            the <emphasis>gLS</emphasis> layer.  The answers to these types of
            queries should be contact information where a
            <command>Query</command> should be issued.
          </para>
        </listitem>
        <listitem>
          <para>
            <command>Query</command> - A series of parameters should deliver
            <emphasis>specific</emphasis> results (e.g. metadata or data
            elements) from the <emphasis>hLS</emphasis> layer where services
            are directly registering.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Information structure and location may be of little to no use to the
      typical perfSONAR client or service.  In general it assumed that queries
      should be simply asked and the end result returned without needing to
      worry about the additional discovery phase between
      <emphasis>gLS</emphasis> and <emphasis>hLS</emphasis> instances.  As such
      the API should be structured in such a way that the
      <emphasis>high level</emphasis> use cases be of the utmost importance, but
      lower level functionality that is able to expose more primitive operations
      should remain available.  The following breakdown isolates the various
      functions:
    </para>

    <table frame="all" align="center" halign="center" width="80%"  id="table.2">
      <title>LS API</title>
      <tgroup cols="1" align="left" colsep="1" rowsep="1">
        <colspec colnum="1" colname="c1"/>
        <colspec colnum="2" colname="c2"/>
        <colspec colnum="3" colname="c3"/>
        <colspec colnum="4" colname="c4"/>
        <thead>
          <row>
            <entry>API Level</entry>
            <entry>Message Type</entry>
            <entry>Event Type</entry>
            <entry>Input</entry>
            <entry>Output</entry>
            <entry>Purpose</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry morerows="3" valign="middle" align="center"><xref linkend="level0_api" /></entry>
            <entry morerows="7" valign="middle">LSQueryRequest</entry>
            <entry>service.lookup.xquery</entry>
            <entry morerows="3" valign="middle">XQuery</entry>
            <entry morerows="3" valign="middle">Raw XML</entry>
            <entry morerows="3" valign="middle">Most primitive call.</entry>
          </row>
          <row>
            <entry>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/xquery/1.0</entry>
          </row>      
          <row>
            <entry>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/discovery/xquery/2.0</entry>
          </row>   
          <row>
            <entry>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/query/xquery/2.0</entry>
          </row>   
          <row>
            <entry morerows="1" valign="middle" align="center"><xref linkend="level1_api" /></entry>
            <entry>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/discovery/xquery/2.0</entry>
            <entry>IP, Domain, eventType, Service Data</entry>
            <entry>hLS URL</entry>
            <entry>Standalone Discovery</entry>
          </row>
          <row>
            <entry>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/query/xquery/2.0</entry>
            <entry>IP, Domain, eventType, Service Data</entry>
            <entry>Metadata (e.g. Service/Measurement based)</entry>
            <entry>Standalone Query</entry>
          </row>
          <row>
            <entry morerows="1" valign="middle" align="center"><xref linkend="level2_api" /></entry>
            <entry>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/discovery/xquery/2.0</entry>
            <entry morerows="1" valign="middle">IP, Domain, eventType, Service Data</entry>
            <entry morerows="1" valign="middle">Metadata (e.g. Service/Measurement based)</entry>
            <entry morerows="1" valign="middle">Complete Discovery/Query</entry>
          </row>
          <row>
            <entry>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/query/xquery/2.0</entry>
          </row>   
        </tbody>
      </tgroup>
    </table>

    <para>
      We will now explain in greater detail the expected  format of the API for
      the various levels, including function names, parameter lists, as well
      as expected behaviors.
    </para>

    <section id="level0_api" xreflabel="0">
      <title>Level 0 API</title>
    
      <para>
        The Level 0 API is based on the current query method used in the
        <emphasis>LS</emphasis>: <command>LSQueryRequest</command> messages
        sending a raw <command>XQuery</command> string.  We would like to keep
        this base functionality for two reasons:
      </para>
      
      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <para>
              This method will serve as the base that upper levels of this API
              use to communicate with the framework.
            </para>
          </listitem>
          <listitem>
            <para>
              It provides an <emphasis>expert</emphasis> interface for service
              designers looking for specific information and not wishing to go
              through the API.
            </para>
          </listitem>
        </itemizedlist>      
      </para>
      
      <para>
        There are only minor modifications that must be made to the existing
        <command>LSQueryRequest</command> functionality, mainly the addition of
        two new <emphasis>eventType</emphasis>s.  These
        <emphasis>eventType</emphasis>s will not only help this level isolate
        the specific dataset to query, but provided needed functionality to the 
        abstractions built on top of Level 0:
      </para>

      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <para>
              <command>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/discovery/xquery/2.0</command>
              - Allows the <command>XQuery</command> to travel directly to the specific
              backend storage holding summarization information.
            </para>
          </listitem>
          <listitem>
            <para>
              <command>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/query/xquery/2.0</command>
              - Allows the <command>XQuery</command> to travel directly to the specific
              backend storage holding registered information.
            </para>
          </listitem>
        </itemizedlist>      
      </para>
      
      <para>
        These <emphasis>eventType</emphasis>s are more of an
        <emphasis>ease of design</emphasis> feature for the implementers of the
        <emphasis>gLS</emphasis> and <emphasis>hLS</emphasis> due to the nature
        of the backend storage mechanisms.  The existing
        <emphasis>eventType</emphasis>s, as well as message structure regarding
        subject and parameters, will remain unchanged.
      </para>


      <para>
        Addtional considerations for this level of the API revolve around the
        internal representation of when data is set to expire, namely the
        <emphasis>LSStore-control</emphasis> structure.  It is desirable to
        have access to this when providing status reports about registered
        information.  This would require two new
        <emphasis>eventType</emphasis>s:
      </para>
      
      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <para>
              <command>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/discovery/control/xquery/2.0</command>
              - Allows the <command>XQuery</command> to travel directly to the specific
              backend storage holding summarization control information.
            </para>
          </listitem>
          <listitem>
            <para>
              <command>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/query/control/xquery/2.0</command>
              - Allows the <command>XQuery</command> to travel directly to the specific
              backend storage holding registered control information.
            </para>
          </listitem>
        </itemizedlist>      
      </para>

      <para>
        An API breakdown follows:
      </para>

      <table frame="all" align="center" halign="center" width="80%"  id="table.api.l0">
        <title>Level 0 API Calls</title>
        <tgroup cols="1" align="left" colsep="1" rowsep="1">
          <colspec colnum="1" colname="c1" />
          <colspec colnum="2" colname="c2" />
          <colspec colnum="3" colname="c3" />
          <thead>
            <row>
              <entry>Function Name</entry>
              <entry>Input</entry>
              <entry>Output</entry>
              <entry>Purpose</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>getLSDiscoverRaw</entry>
              <entry morerows="1" valign="middle">XQuery String</entry>
              <entry morerows="1" valign="middle">Raw XML (e.g. Data/Metadata pairs in an array)</entry>
              <entry>Send XQuery for results in the <emphasis>Summary</emphasis>
                storage only.</entry>
            </row>
            <row>
              <entry>getLSQueryRaw</entry>
              <entry>Send XQuery for results in the <emphasis>Registered</emphasis>
                storage only.</entry>
            </row>
             <row>
                <entry>getLSDiscoverControlRaw</entry>
                <entry morerows="1" valign="middle">XQuery String</entry>
                <entry morerows="1" valign="middle">Raw XML (e.g. Data/Metadata pairs in an array)</entry>
                <entry>Send XQuery for results in the <emphasis>Summary</emphasis>
                  control storage only.</entry>
              </row>
              <row>
                <entry>getLSQueryControlRaw</entry>
                <entry>Send XQuery for results in the <emphasis>Registered</emphasis>
                  control storage only.</entry>
              </row>
          </tbody>
        </tgroup>
      </table>

    </section>

    <section id="level1_api" xreflabel="1">
      <title>Level 1 API</title>
    
      <para>
        The Level 1 API offers a the first true way of abstracting the queries
        to the LS by identifying a series of well defined parameters as input
        as well as structured output.  This particular portion of the API will
        not try to unify the roles of <emphasis>Discovery</emphasis> and
        <emphasis>Query</emphasis> in favor of keeping these tasks seperate to
        act as building blocks for client and service applications alike.  This
        level will not require any additional modifications to be made to the
        <command>LSQueryRequest</command>, as it will utilize Level 0 API calls.
      </para>

      <para>
        An API breakdown follows:
      </para>

      <table frame="all" align="center" halign="center" width="80%"  id="table.api.l1">
        <title>Level 1 API Calls</title>
        <tgroup cols="1" align="left" colsep="1" rowsep="1">
          <colspec colnum="1" colname="c1" />
          <colspec colnum="2" colname="c2" />
          <colspec colnum="3" colname="c3" />
          <thead>
            <row>
              <entry>Function Name</entry>
              <entry>Input</entry>
              <entry>Output</entry>
              <entry>Purpose</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>getLSDiscoverEventType</entry>
              <entry>EventType</entry>
              <entry>hLS URL</entry>
              <entry>Given an <emphasis>eventType</emphasis>, return <emphasis>hLS</emphasis>s</entry>
            </row>
            <row>
              <entry>getLSDiscoverAddress</entry>
              <entry>IP Address</entry>
              <entry>hLS URL</entry>
              <entry>Given an IP Address, return <emphasis>hLS</emphasis>s</entry>
            </row>
            <row>
              <entry>getLSDiscoverDomain</entry>
              <entry>Domain</entry>
              <entry>hLS URL</entry>
              <entry>Given a Domain, return <emphasis>hLS</emphasis>s</entry>
            </row>
            <row>
              <entry>getLSDiscoverService</entry>
              <entry>Service Type</entry>
              <entry>hLS URL</entry>
              <entry>Given a Service Type, return <emphasis>hLS</emphasis>s</entry>
            </row>
            <row>
              <entry>getLSQueryEventType</entry>
              <entry>EventType</entry>
              <entry>Metadata Array</entry>
              <entry>Given an <emphasis>eventType</emphasis>, return array of metadata.</entry>
            </row>
            <row>
              <entry>getLSQueryAddress</entry>
              <entry>IP Address</entry>
              <entry>Metadata Array</entry>
              <entry>Given an IP Address, return array of metadata.</entry>
            </row>
            <row>
              <entry>getLSQueryDomain</entry>
              <entry>Domain</entry>
              <entry>Metadata Array</entry>
              <entry>Given a Domain, return array of metadata.</entry>
            </row>
            <row>
              <entry>getLSQueryService</entry>
              <entry>Service Type</entry>
              <entry>Service Metadata Array</entry>
              <entry>Given a Service Type, return array of metadata.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section id="level1_api_ext" xreflabel="1 Extension">
        <title>Level 1 API Extension</title>

        <para>
          The following extension may be made to the <command>Level 0</command>
          functions dealing with access to the
          <emphasis>LSStore-control</emphasis> structures. These formats are
          presented mearly as a suggestion as they are optional to the overall
          success of the framework.  Note there are not specific
          <emphasis>Discovery</emphasis> calls here as the same job could be
          accomplished with the previous descriptions.  The only purpose of this
          API is to return the actual time values associated to a registered 
          service instead of having to deal with raw XML as done in
          <command>Level 0</command>.
        </para>
      
        <para>
          An API breakdown follows:
        </para>

        <table frame="all" align="center" halign="center" width="80%"  id="table.api.l1.c">
          <title>Additional Level 1 API Calls</title>
          <tgroup cols="1" align="left" colsep="1" rowsep="1">
            <colspec colnum="1" colname="c1" />
            <colspec colnum="2" colname="c2" />
            <colspec colnum="3" colname="c3" />
            <thead>
              <row>
                <entry>Function Name</entry>
                <entry>Input</entry>
                <entry>Output</entry>
                <entry>Purpose</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>getLSQueryControlService</entry>
                <entry>Service Type, Name, AccessPoint</entry>
                <entry>Time Array</entry>
                <entry>Given service information, return array of times.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

      </section>
      
    </section>
    
    <section id="level2_api" xreflabel="2">
      <title>Level 2 API</title>
    
      <para>
        The highest level of this API will perform all work with regards to 
        discovery and query in a single call.  It is expected that services and
        client applications will make use of this API instead of manually using
        the previous 2 layers.
      </para>
      
      <para>
        An API breakdown follows:
      </para>

      <table frame="all" align="center" halign="center" width="80%"  id="table.api.l2">
        <title>Level 2 API Calls</title>
        <tgroup cols="1" align="left" colsep="1" rowsep="1">
          <colspec colnum="1" colname="c1" />
          <colspec colnum="2" colname="c2" />
          <colspec colnum="3" colname="c3" />
          <thead>
            <row>
              <entry>Function Name</entry>
              <entry>Input</entry>
              <entry>Output</entry>
              <entry>Purpose</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>getLSEventType</entry>
              <entry>EventType</entry>
              <entry>Metadata Array</entry>
              <entry>Given an <emphasis>eventType</emphasis>, return array of metadata.</entry>
            </row>
            <row>
              <entry>getLSAddress</entry>
              <entry>IP Address</entry>
              <entry>Metadata Array</entry>
              <entry>Given an IP Address, return array of metadata.</entry>
            </row>
            <row>
              <entry>getLSDomain</entry>
              <entry>Domain</entry>
              <entry>Metadata Array</entry>
              <entry>Given a Domain, return array of metadata.</entry>
            </row>
            <row>
              <entry>getLSService</entry>
              <entry>Service Type</entry>
              <entry>Service Metadata Array</entry>
              <entry>Given a Service Type, return array of metadata.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>      

      <section id="level2_api_ext" xreflabel="2 Extension">
        <title>Level 2 API Extension</title>

        <para>
          The following extension may be made to the <command>Level 0</command>
          and <command>Level 1</command> functions dealing with access to the
          <emphasis>LSStore-control</emphasis> structures. These formats are
          presented mearly as a suggestion as they are optional to the overall
          success of the framework.
        </para>
      
        <para>
          An API breakdown follows:
        </para>

        <table frame="all" align="center" halign="center" width="80%"  id="table.api.l2.c">
          <title>Additional Level 2 API Calls</title>
          <tgroup cols="1" align="left" colsep="1" rowsep="1">
            <colspec colnum="1" colname="c1" />
            <colspec colnum="2" colname="c2" />
            <colspec colnum="3" colname="c3" />
            <thead>
              <row>
                <entry>Function Name</entry>
                <entry>Input</entry>
                <entry>Output</entry>
                <entry>Purpose</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>getLSControlService</entry>
                <entry>Service Type, Name, AccessPoint</entry>
                <entry>Time Array</entry>
                <entry>Given service information, return array of times.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

      </section>

    </section>

  </section>

  <section id="operation" xreflabel="Operation">
    <title>Operation</title>
    
    <para>
      <command>TBD</command>
    </para>
    
  </section>

  <section id="implementation" xreflabel="Implementation">
    <title>Implementation</title>
    
    <para>
      The following sections detail notes on implementation.  These will change
      as the development effort progresses, and eventually will be moved
      into individual service documentation.
    </para>

    <section id="implementation_java" xreflabel="Java Considerations">
      <title>Java Considerations</title>
    
      <para>
        <command>TBD</command>
      </para>
    
    </section>

    <section id="implementation_perl" xreflabel="Perl Considerations">
      <title>Perl Considerations</title>
    
      <para>
        The following represents a list of changes that must be made to the
        Perl implementation along with related commentary.
      </para>
      
      <para>
        <itemizedlist mark='opencircle'>
          <listitem>
            <para>
              <xref linkend="implementation_perl_mode" /> - The
              <emphasis>gLS</emphasis> will have special functionality beyond
              the <emphasis>hLS</emphasis> and vice versa.
            </para>
          </listitem>
          <listitem>
            <para>
              <xref linkend="implementation_perl_summarization" /> - The data
              must be summarized in some way and conveyed to the
              <emphasis>gLS</emphasis> layer.
            </para>
          </listitem>
          <listitem>
            <para>
              <xref linkend="implementation_perl_storage" /> - The summarized
              data must be stored somewhere.
            </para>
          </listitem>
          <listitem>
            <para>
              <xref linkend="implementation_perl_registration" /> - Changes to
              how we treat the act of registration.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <section id="implementation_perl_mode" xreflabel="gLS and hLS Operation Differences">
        <title>gLS and hLS Operation Differences</title>
        
        <para>
          The <emphasis>gLS</emphasis> must contain the following functionality
          that is not currently found (or should be turned off in) in the LS:
        </para>
        
        <para>
          <itemizedlist mark='opencircle'>
            <listitem>
              <para>
                Only allow registration of hLS instances with the summary
                data type (optional, with <emphasis>self registration</emphasis>
                this can be worked around).
              </para>
            </listitem>
            <listitem>
              <para>
                Self Registration.
              </para>
            </listitem>
            <listitem>
              <para>
                Ability to answer Discovery Queries (requires modification).
              </para>
            </listitem>
            <listitem>
              <para>
                Ability to answer Queries (amount that is implemented depends on
                <emphasis>self registration</emphasis>).
              </para>
            </listitem>
          </itemizedlist>
        </para>

        <para>
          The <emphasis>hLS</emphasis> must contain the following functionality
          that is not currently found (or should be turned off in) in the LS:
        </para>

        <para>
          <itemizedlist mark='opencircle'>
            <listitem>
              <para>
                Only allow registration of non LS instances.
              </para>
            </listitem>
            <listitem>
              <para>
                Self Registration.
              </para>
            </listitem>
            <listitem>
              <para>
                Ability to answer Queries (requires modification).
              </para>
            </listitem>
            <listitem>
              <para>
                Ability to answer Discovery Queries (depends on self
                registration).  
              </para>
            </listitem>
          </itemizedlist>
        </para>
        
        <para>
          A proposed solution to use the same code base for both services is the
          inclusion of a configuration switch indicating the mode of operation.
          This mode can be <emphasis>hLS</emphasis> by default and perhaps
          not even asked about during configuration (this will ensure that
          a user inadvertently deploys a <emphasis>gLS</emphasis> instead of a
          <emphasis>hLS</emphasis>).  To enable the <emphasis>gLS</emphasis>
          mode the switch will manually need to be edited in the
          <command>daemon.conf</command> file.
        </para>
        
      </section>    
      
      <section id="implementation_perl_summarization" xreflabel="Summarizing Registered Data">
        <title>Summarizing Registered Data</title>
        
        <para>
          Using the example code in
          <xref linkend="appendix_summarization_source_perl" />, a summarization
          of the registered data should be completed on-demand (e.g. If new
          information is registered, the summary should be re-run and the
          information re-registered with the <emphasis>gLS</emphasis> layer.
        </para>
        
        <para>
          This method may cause performance issues, testing will need to reveal
          if a periodic summarization event will lead to better operation (at
          the detriment of information location). 
        </para>
        
        <para>
          Storage of the <emphasis>self</emphasis> summary is also an issue
          that will need to be examined.  It makes sense from an organization
          standpoint to keep all summarized info together, but having a faster
          <emphasis>cache</emphasis> of your own summary may prove to be
          worthwhile.
        </para>
        
      </section>  
      
      <section id="implementation_perl_storage" xreflabel="Storage Reorganization">
        <title>Storage Reorganization</title>
        
        <para>
          Currently it is an option to specify the name of the collection that
          the registered data will reside in (e.g.
          <emphasis>store.dbxml</emphasis> or similar).  We will require the
          same thing for a summary container (e.g.
          <emphasis>summary.dbxml</emphasis>).  Giving the option of the
          collection names is a bit troublesome, especially for a user who
          doesn't really care.  We are proposing only giving one option to the
          user, the <emphasis>location</emphasis> of the XML Database (e.g. 
          <emphasis>/etc/perfsonar/ls_xmldb</emphasis>) and simply providing 
          well known container names.
        </para>
        
        <para>
          This will also help with the new <emphasis>eventType</emphasis>s used
          to route the query to the proper data set.  A well known container
          is much easier to query than checking the configuration for the 
          exact container name, and modifying the existing
          <emphasis>XQuery</emphasis> to take this into consideration.
        </para>
      </section>  
      
      <section id="implementation_perl_registration" xreflabel="Multiple and Self Registration">
        <title>Multiple and Self Registration</title>
        
        <para>
          Currently the tooling to support registration to multiple LS instances
          is not as error resistant as it should be.  The operation works, but
          does not do much in the way of checking the result codes of each
          registered metadata/data pair.  This should be addressed in this service.
        </para>
        
        <para>
          Self registration will be required to ensure that you maintain your
          own summary information.  This will mean using the accessPoint as
          a <emphasis>default</emphasis> LS instance.  This will also mean
          addressing the storage issue discussed in
          <xref linkend="implementation_perl_storage" />.
        </para>
        
      </section>  
    
    </section>
    
  </section>

  <section id="appendix" xreflabel="Appendix">
    <title>Appendix</title>
    
    <para>
      The following sections describe some of the more concreate details of this
      implementation when applicable.
    </para>
    
    <section id="appendix_summary" xreflabel="Summary Message Example">
      <title>Summary Message Example</title>
    
      <para>
        Each <emphasis>hLS</emphasis> instance must register a summary of the
        data it is aware of with the <emphasis>gLS</emphasis> or 
        <emphasis>gLS</emphasis>s it communicates with.  This summary should
        be of the format described below.
      </para>

      <programlisting>
        <![CDATA[
          <inlinexml file="examples/ex.xml"/>
        ]]>
      </programlisting> 
    
    </section>

    <section id="appendix_summarization_source" xreflabel="Summarization Source Code">
      <title>Summarization Source Code</title>
    
      <para>
        As a proof of concept to performing a rudimentary
        <emphasis>K Dominators</emphasis> identification of the IP addresses an
        <emphasis>hLS</emphasis> will know of consider the following source
        code written in both Java and Perl.
      </para>

      <section id="appendix_summarization_source_java" xreflabel="Summarization Source Code (Java)">
        <title>Summarization Source Code (Java)</title>

        <para>
          <command>TBD</command>
        </para>

      </section>    

      <section id="appendix_summarization_source_perl" xreflabel="Summarization Source Code (Perl)">
        <title>Summarization Source Code (Perl)</title>

        <programlisting>
          <![CDATA[
            <inline file="examples/ipTree.pl"/>
          ]]>
        </programlisting> 

        <para>
          Some things to note:
        </para>

        <para>
          <itemizedlist mark='opencircle'>
            <listitem>
              <para>This script uses two external perl libraries
              (<emphasis>Net::CIDR</emphasis> and
              <emphasis>Net::IPTrie</emphasis>) to solve this problem.  Similar
              libraries may not be available in Java, but can easily be
              re-created.</para>
            </listitem>
            <listitem>
              <para>The output (shown below) is currently used to create a 
              <citation>Graphviz</citation> formated image.  The script can be
              modified to output the tree in a more readable format.</para>
            </listitem>
            <listitem>
              <para>This script does not allow one to specifiy a set value for
              <emphasis>K</emphasis> and return only those dominators.  A simple
              walk of the tree should be able to perform this task.</para>
            </listitem>
          </itemizedlist>
        </para>

        <para>
          The following output represents a <emphasis>Graphviz</emphasis>
          description of a DAG.  
        </para>

        <programlisting>
          <![CDATA[
            <inline file="examples/graph.dot"/>
          ]]>
        </programlisting> 
    
        <para>
          This image was created from the above source and represents the
          dominators (in CIDR notation) as well as the original endpoints
          (represented in red).
        </para>

        <para>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/graph.png"/>
            </imageobject>
          </mediaobject>
        </para>  

      </section>    

    </section>

    <section id="appendix_synch" xreflabel="Synchronization Example">
      <title>Synchronization Example</title>

      <para>
        The following example illustrates synchronization using the 
        perfSONAR-PS framework mainly for backup up <emphasis>DCN</emphasis>
        registered information.  This small snippet of code is currently used
        to provie a <emphasis>backup</emphasis> LS for both replication and
        backup purposes.  This code would need modification for inclusion into
        the <emphasis>gLS</emphasis> to address the issues of registration
        and de-registration of <emphasis>only</emphasis> data a given
        <emphasis>gLS</emphasis> is authoritative for.
      </para>

      <programlisting>
        <![CDATA[
          <inline file="examples/sync.pl"/>
        ]]>
      </programlisting> 

    </section>
        
  </section>

  <glossary id="glossary">
    <title>Terms</title>

    <glossdiv id="A">
      <title>A</title>     
    </glossdiv> 
    
    <glossdiv id="B">
      <title>B</title>   
    </glossdiv> 
    
    <glossdiv id="C">
      <title>C</title>     
    </glossdiv> 
    
    <glossdiv id="D">
      <title>D</title>   
 
    </glossdiv> 
    
    <glossdiv id="E">
      <title>E</title>    
    </glossdiv> 
    
    <glossdiv id="F">
      <title>F</title>         
    </glossdiv> 
    
    <glossdiv id="G">
      <title>G</title>    
      <glossentry id="gLS"><glossterm>gLS</glossterm>
        <glossdef>
          <para>
            A <emphasis>globally</emphasis> acessible Lookup Service.
          </para>
        </glossdef>
      </glossentry>   
    </glossdiv> 
    
    <glossdiv id="H">
      <title>H</title>   
      <glossentry id="hLS"><glossterm>hLS</glossterm>
        <glossdef>
          <para>
            The <emphasis>home</emphasis> Lookup Service.
          </para>
        </glossdef>
      </glossentry>        
    </glossdiv> 
    
    <glossdiv id="I">
      <title>I</title>           
    </glossdiv> 
    
    <glossdiv id="J">
      <title>J</title>    
    </glossdiv> 
    
    <glossdiv id="K">
      <title>K</title>    
    </glossdiv> 
    
    <glossdiv id="L">
      <title>L</title>    
    </glossdiv> 
    
    <glossdiv id="M">
      <title>M</title>       
    </glossdiv> 
    
    <glossdiv id="N">
      <title>N</title>  
    </glossdiv> 
    
    <glossdiv id="O">
      <title>O</title>    
    </glossdiv> 
    
    <glossdiv id="P">
      <title>P</title>     
    </glossdiv>
    
    <glossdiv id="Q">
      <title>Q</title>    
    </glossdiv> 
    
    <glossdiv id="R">
      <title>R</title>  
    </glossdiv> 
    
    <glossdiv id="S">
      <title>S</title>   
    </glossdiv> 
    
    <glossdiv id="T">
      <title>T</title>      
    </glossdiv> 
    
    <glossdiv id="U">
      <title>U</title>  
    </glossdiv> 
    
    <glossdiv id="V">
      <title>V</title>    
    </glossdiv> 
    
    <glossdiv id="W">
      <title>W</title>    
    </glossdiv> 
    
    <glossdiv id="X">
      <title>X</title>  
    </glossdiv> 
    
    <glossdiv id="Y">
      <title>Y</title>    
    </glossdiv> 
    
    <glossdiv id="Z">
      <title>Z</title>    
    </glossdiv>
     
  </glossary>

  <bibliography id="bibliography">
    <title>References</title>

    <biblioentry xreflabel="dLS Design Document">
      <abbrev>dLS</abbrev>
      <title>
        <ulink url="http://anonsvn.internet2.edu/svn/nmwg/trunk/nmwg/doc/dLS/dLS_spec_1.html">http://anonsvn.internet2.edu/svn/nmwg/trunk/nmwg/doc/dLS/dLS_spec_1.html</ulink>
      </title>
    </biblioentry>  

    <biblioentry xreflabel="ESnet">
      <abbrev>ESnet</abbrev>
      <title>
        <ulink url="http://www.es.net">http://www.es.net</ulink>
      </title>
    </biblioentry>  

    <biblioentry xreflabel="Geant2">
      <abbrev>Geant2</abbrev>
      <title>
        <ulink url="http://www.geant2.net">http://www.geant2.net</ulink>
      </title>
    </biblioentry>  

    <biblioentry xreflabel="Internet2">
      <abbrev>Internet2</abbrev>
      <title>
        <ulink url="http://www.internet2.edu">http://www.internet2.edu</ulink>
      </title>
    </biblioentry>  
    
    <biblioentry xreflabel="RNP">
      <abbrev>RNP</abbrev>
      <title>
        <ulink url="http://www.rnp.br/en">http://www.rnp.br/en</ulink>
      </title>
    </biblioentry>  

    <biblioentry xreflabel="XPath">
      <abbrev>XPath</abbrev>
      <title>
        <ulink url="http://www.w3.org/TR/xpath">XPath</ulink>
      </title>
    </biblioentry> 
    
    <biblioentry xreflabel="XQuery">
      <abbrev>XQuery</abbrev>
      <title>
        <ulink url="http://www.w3.org/TR/xquery/">XQuery</ulink>
      </title>
    </biblioentry> 

    <biblioentry xreflabel="Graphviz">
      <abbrev>Graphviz</abbrev>
      <title>
        <ulink url="http://www.graphviz.org/">Graphviz</ulink>
      </title>
    </biblioentry> 

  </bibliography>

</article>
