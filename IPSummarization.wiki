#summary IP Summarization Algorithm in Perl<wiki:toc max_depth="6" />== Introduction ==The effective and efficient summarization of the IPv4 (and eventually IPv6) address space is paramount for the Information services of perfSONAR.  The current algorithm has been the mainstay since advent of the gLS, and may take liberties with the final output:

 * Summarization is not as _tight_ as possible.  For instance given several addresses that share an A class subnet (e.g. 192.168.0.56, 192.168.48.98, 192.168.48.197) a larger than required CIDR recommendation is made: 192.0.0.0/8.  
 * Multiple ranges may confuse the overall output.  If two primary ranges are seen, 192.168.0.0/16 and 10.10.0.0/16, the recommendation may be returned that is even greater, e.g. 0.0.0.0/0.

Implementations should also consider:

 * Efficiency for input size
 * Internal data structures, such as IPTrie.  
 
The following document describes the current state of the algorithm and then lays out recommendations for upgrade as well as a work plan.  Schedules are not exact.

== Current ==

The current algorithm was developed by Jason and Martin in the Spring/Summer of 2008.  This culminated in the release of the perfSONAR-PS gLS for June of 2008.  

=== Current Algorithm ===

This algorithm makes heavy use of the concept of an IPTrie data structure.  A basic description follows:

 # Read in complete list of IP addresses.  For a given hLS the pattern should be similar to:
   * Many distinct addresses in a certain range (e.g. an SNMP MA is deployed in a single domain).
   * Potentially several ranges (if the hLS is shared)
   * _Outliers_, this is seen for point to point services such as _PingER_ and _perfSONAR-BUOY_
 # Given our list of IP addresses we need to groom the data.
   * CIDR Summarization (using [http://search.cpan.org/dist/Net-CIDR/CIDR.pm Net::CIDR]).  We really want to get _*all*_ CIDR summaries for any IP Address (simply put, what _range_ is a given IP address valid in). An Example using _*128.4.133.164*_.  A complete list of CIDR descriptions follows:
{{{
       128.4.133.164/32
       128.4.133.164/31
       128.4.133.164/30
       128.4.133.160/29
       128.4.133.160/28
       128.4.133.160/27
       128.4.133.128/26
       128.4.133.128/25
       128.4.133.0/24
       128.4.132.0/23
       128.4.132.0/22
       128.4.128.0/21
       128.4.128.0/20
       128.4.128.0/19
       128.4.128.0/18
       128.4.128.0/17
       128.4.0.0/16
       128.4.0.0/15
       128.4.0.0/14
       128.0.0.0/13
       128.0.0.0/12
       128.0.0.0/11
       128.0.0.0/10
       128.0.0.0/9
       128.0.0.0/8
       128.0.0.0/7
       128.0.0.0/6
       128.0.0.0/5
       128.0.0.0/4
       128.0.0.0/3
       128.0.0.0/2
       128.0.0.0/1
       0.0.0.0/0
}}}
   * The next step involves looking at these numbers for _all_ IP addresses that we started with.  For lack of a better term I refer to this as _*voting*_.  We keep a running tally of how many of the starting addresses share the common ancestors of CIDR descriptions.  An example using _*128.4.40.17*_ and _*128.4.133.164*_.  These addresses share the following CIDR ranges, with the _tightest_ being at the top.
{{{
       128.4.0.0/16
       128.4.0.0/15
       128.4.0.0/14
       128.0.0.0/13
       128.0.0.0/12
       128.0.0.0/11
       128.0.0.0/10
       128.0.0.0/9
       128.0.0.0/8
       128.0.0.0/7
       128.0.0.0/6
       128.0.0.0/5
       128.0.0.0/4
       128.0.0.0/3
       128.0.0.0/2
       128.0.0.0/1
       0.0.0.0/0
}}}
 # Next we need to make the IPTrie (e.g. Patricia Trie - we use the [http://search.cpan.org/~cvicente/Net-IPTrie-v0.4/lib/Net/IPTrie.pm Net::IPTrie] module).  Making the Trie consists of:
   # Insert all of the original addresses into the Trie with a /32 prefix.  This does not need to be done in order.
   # Insert all of the _voted_ and shared CIDR ranges _*in order, from most to least*_.  The ordering matters here for Trie construction.
 # After we have our Trie we have the option of _pruning_ it to remove dead ends
 # Finally we do a walk of the Trie to print out (for Graphical Purposes) and to establish:
   # _*Maximum Dominator*_ - Find the _tightest_ CIDR range for all inputs
   # _*K Dominators*_ - Walk _down the tree_, towards the leaves, and find the _K_ dominators that still describe all leaves in the _tightest_ possible manner.
 
=== Example ===

Consider this input set of data, representative of some service:

{{{
    128.175.13.92
    128.175.13.74
    128.4.40.10
    128.4.40.12
    128.4.40.17
    128.4.131.23
    128.4.133.167
    128.4.133.163
    128.4.133.164
}}}

When all is said and done, we are left with the following Trie (when using the above algorithm:

http://perfsonar-ps.googlecode.com/svn/wiki/IPSummarization/graph.png

The top CIDR, _*128.0.0.0/8*_, dominates all leaves and is as _tight_ as possible.   To select the _K_ dominators we can craft an arbitrary rule to _slice_ off portions of the tree that directly touch a leaf:

http://perfsonar-ps.googlecode.com/svn/wiki/IPSummarization/graph2.png

This allows us to choose 3 dominators:
{{{
    128.175.13.64/27
    128.4.128.0/21
    128.4.40.0/27
}}}

=== Current Implementation ===

The following is a short script that implements the above algorithm.  It is written in perl and currently present in all production gLS instances.  Comments are inserted where obvious changes to the algorithm were made.  Important deviations:

 # The IPTrie object is not sound.  Modifications to the Trie are required after construction to properly link the pointers of children and parents.  For this reason we may wish to implement our own IPTrie.  It remains because it does offer some useful functions (e.g. printing out the Trie)
 # Voting is rather simple.  We simply rank by shared parent
 # Graphviz notation provided to make pretty pictures.

{{{
#!/usr/bin/perl -w

use strict;
use warnings;

=head1 NAME

ipTree.pl - Utility to demonstrate the effectivness of CIDR summarizations of
IP addresses as well as a potential solution to finding dominating values
when used in a Radix Tree (Patricia Trie) data structure.

=head1 USAGE

  perl ipTree.pl

An outputed list of the minimum dominators of the resulting IPTrie will be
be displayed.  This will generate a graphviz .dot file (graph.dot) of the
IPTrie that can then be used with the graphviz executable:

  dot graph.dot -Tpng -o graph.png

=head1 DESCRIPTION

The perfSONAR dLS and gLS require a way to summarize large amounts of
topological data (namely IP addresses of type IPv4 and IPv6).  Using the
well known CIDR way of specificying IP address ranges, this simple script aims
to combine the 'dominating' (i.e. greatest available CIDR summaries) for some
set of source IP addresses.

The output is placed into a graphviz dot file for display.

=cut

use Net::CIDR ':all';
use Net::IPTrie;
use Data::Dumper;

# IP Trie Data Structure (similar to Net::Patricia)
my $tr = Net::IPTrie->new( version => 4 );

# I need to be able to do my own manipulations (e.g. IPTrie is not really
# that great...)
my %tree = ();

# Ensure that each child only has one parent (IPTrie data structure
# uses a strange internal representation).
my %claim = ();

# starting list of IPs

my @map = ( "128.175.13.92", "128.175.13.74", "128.4.40.10", "128.4.40.12", "128.4.40.17", "128.4.131.23", "128.4.133.167", "128.4.133.163", "128.4.133.164" );

#my @map = ("150.254.160.194",
#           "150.254.160.195",
#           "150.254.160.196",
#           "120.10.0.11",
#           "120.10.0.12",
#           "120.10.0.17",
#           "120.11.5.1",
#           "120.11.5.2",
#           "80.15.11.2",
#           "80.15.11.3");

#my @map = ("64.57.25.15",
#           "64.57.27.4",
#           "64.57.27.138",
#           "128.4.12.12",
#           "128.4.13.1",
#           "160.135.1.1",
#           "207.75.165.151",
#           "207.72.226.18",
#           "206.72.224.1");

my $vote = getCDIRSummaries( \@map );
$tr = makePatriciaTrie( \@map, $vote, $tr );
manipulatePatriciaTrie( \@map, $tr );
genGraph( \%tree );
listMinDoms();

exit( 1 );

=head2 getCDIRSummaries($map)

Given a list of IP addresses, gather the CIDR representations then 
group this by a popularity ranking (i.e. if there are 9 hosts, and 9
have a set grouping of CIDR values in common, this is a dominator).

=cut

sub getCDIRSummaries {
    my ( $map ) = @_;

    my %tally = ();
    foreach my $host ( @{$map} ) {
        my @list = Net::CIDR::addr2cidr( $host );
        foreach my $range ( @list ) {

            # we want to ingore the wildcard addresses...
            next if $range =~ m/^0\./;

            $tally{$range}++ if defined $tally{$range};
            $tally{$range} = 1 if not defined $tally{$range};
        }
    }

    return \%tally;
}

=head2 makePatriciaTrie($map, $votes, $tr)

Creates the initial IPTrie structure using the list of 
available hosts (e.g. $map) and the CIDR values for
each (ranked into popularity groups).  The end result is
the IPTrie.

=cut

sub makePatriciaTrie {
    my ( $map, $tally, $tr ) = @_;

    # Start to make the IPTrie data structure.  First we add in all
    # of the 'base' addresses

    foreach my $host ( @{$map} ) {
        $tr->add( address => $host, prefix => "32" );
    }

    # Now we add in the summaries.

    foreach my $t ( sort keys %{$tally} ) {
        my @parts = split( /\//, $t );
        $tr->add( address => $parts[0], prefix => $parts[1] );
    }

    return $tr;
}

=head2 extract($parent, $node, $status, $side)

This aux function recursively walks the nodes of the IPTrie structure
and creates a more usefriendly tree that we will use for manipulation
and final display.

=cut

sub extract {
    my ( $parent, $node, $status, $side ) = @_;
    my $me = "";
    $me = $node->[3] . "/" . $node->[5] if defined $node->[3] and defined $node->[5];
    if ( $me and $side and ( not $claim{$me} ) ) {
        push @{ $tree{$parent}{"C"} }, $me;
        $claim{$me} = 1;
    }
    $status = extract( $parent, $node->[1], $status, "L" ) if $node->[1] and ( not $status->{"L"} );
    $status = extract( $parent, $node->[2], $status, "R" ) if $node->[2] and ( not $status->{"R"} );
    return $status;
}

=head2 manipulatePatriciaTrie($tr)

Given the IPTrie structure, we need to manually manipulate the nodes into
our own format.

=cut

sub manipulatePatriciaTrie {
    my ( $map, $tr ) = @_;

    my $list  = ();
    my $code  = sub { push @$list, shift @_; };
    my $count = $tr->traverse( code => $code );

    # hacky root pointer (gives us unification if the whild card [0.*]
    # was really needed)

    my @temp = ();
    $tree{"Root"}{"C"} = \@temp;
    $tree{"Root"}{"U"} = "NULL";

    # we need to go backwards when looking at the IPTrie print out, this is
    # is really to be sure children aren't all claimed by the root (the internal
    # structure is a little strange) so this ensures we hit the root last.

    foreach my $node ( reverse @{$list} ) {
        my $me = "";
        $me = $node->[3] . "/" . $node->[5] if defined $node->[3] and defined $node->[5];
        next unless $me;

        # each one of our node-keys has some location information
        my @temp = ();
        $tree{$me}{"C"} = \@temp;
        $tree{$me}{"U"} = "";

        # recursively search the tree, stop after you find a left and right
        # child though (N.B. this creates problems unfortunately, so we need
        # to manually manipulate...)
        my %status = (
            "L" => 0,
            "R" => 0
        );
        extract( $me, $node, \%status, "" );
    }

    # link all the parent information for each node and child

    foreach my $item ( keys %tree ) {
        foreach my $c ( @{ $tree{$item}{"C"} } ) {
            $tree{$c}{"U"} = $item if $c and $item;
        }
    }

    # First step: Start at the leaves and walk toward the root.
    # - Every time we see a node with a sinle child, collapse it into the parent
    #   (we are pruning the tree)

    foreach my $host ( @{$map} ) {
        my $current = $host . "/32";
        while ( $current ) {
            my $delete = "";
            if (    $#{ $tree{ $tree{$current}{"U"} }{"C"} } == 0
                and not( $current =~ m/\/32$/ )
                and $#{ $tree{$current}{"C"} } == 0 )
            {
                $delete = $current;
                foreach my $child ( @{ $tree{$current}{"C"} } ) {
                    $tree{$child}{"U"} = $tree{$current}{"U"};
                }
                $tree{ $tree{$current}{"U"} }{"C"} = $tree{$current}{"C"};
                delete $tree{$delete}{"C"};
            }
            $current = $tree{$current}{"U"};
            delete $tree{$delete} if $delete;
        }
    }

    # Second step: Start at the leaves and walk toward the root.
    # - Every time we see a single child node, collapse it into the child (this
    #   is the opposite of what we just did, but this handles branching much
    #   better, this is also a form of pruning).

    foreach my $host ( @{$map} ) {
        my $current = $host . "/32";
        while ( $current ) {
            my $delete = "";
            if ( $#{ $tree{$current}{"C"} } == 0 ) {
                $delete = $current;
                foreach my $child ( @{ $tree{$delete}{"C"} } ) {
                    $tree{$child}{"U"} = $tree{$delete}{"U"};
                    push @{ $tree{ $tree{$delete}{"U"} }{"C"} }, $child;
                }

                my $counter = 0;
                foreach my $child ( @{ $tree{ $tree{$delete}{"U"} }{"C"} } ) {
                    if ( $child eq $current ) {
                        my $remove = splice( @{ $tree{ $tree{$delete}{"U"} }{"C"} }, $counter, 1 );
                    }
                    $counter++;
                }
            }
            $current = $tree{$current}{"U"};
            delete $tree{$delete} if $delete;
        }
    }

    # finally link the tree(s) to the root pointer

    foreach my $node ( keys %tree ) {
        unless ( $tree{$node}{"U"} ) {
            $tree{$node}{"U"} = "Root";
            push @{ $tree{"Root"}{"C"} }, $node;
        }
    }

    return;
}

=head2 genGraph

Outputs the contents of the tree structure into a "Graphviz" formated
DAG file.  

=cut

sub genGraph {

    open( DOT, ">graph.dot" );
    print DOT "digraph g {\n";

    foreach my $item ( keys %tree ) {
        next unless $item;
        if ( $item =~ m/\/\d+$/ ) {
            my @array = ();
            @array = split( /\//, $item );

            # color the terminal elements so we know they are not dominators
            if ( $array[1] eq "32" ) {
                print DOT "\t\"", $item, "\"[ color=crimson, style=filled ];\n";
            }
            else {
                print DOT "\t\"", $item, "\";\n";
            }
        }
        else {

            # this is the root...

            print DOT "\t\"", $item, "\"[ color=yellow, style=filled ];\n";
        }
    }

    # output the linkings

    foreach my $item ( keys %tree ) {
        next unless $item;
        foreach my $c ( @{ $tree{$item}{"C"} } ) {
            next unless $c;
            print DOT "\t\"", $item, "\" -> \"", $c, "\";\n";
        }
    }

    print DOT "}\n";
    close( DOT );
    return;
}

=head2 listMinDoms

Given the tree, 'slice off' the top level of nodes that are
not necessarily representative of the domination (e.g. if they
are just used to direct traffic through the tree, and do not
have direct /32 children).  We return a list of nodes that
represent the minimum set of addresses that can be used to
describe any of the originals.

=cut

sub listMinDoms {

    # First locate the root in the tree

    my @expand = ();
    foreach my $node ( sort keys %tree ) {
        if ( $node and $tree{$node}{"U"} eq "Root" ) {

            # add the root the 'expand' list so we can
            # examine it (and it's children, etc.) then
            # exit
            push @expand, $node;
        }
    }

    my $counter = 0;
    my @minDoms = ();

    # now we are going to walk the tree.  If a non-leaf
    # node has two non-leaf children is is useless to us,
    # so we skip it.  If a non-leaf node has at least one
    # leaf child, this is a part of our 'boundary' so
    # we list it as a minDominator.

    while ( $expand[$counter] ) {
        my $minDomFlag = 0;
        my $expandFlag = 0;

        foreach my $child ( sort @{ $tree{ $expand[$counter] }{"C"} } ) {
            my @array = split( /\//, $child );

            # /32's are leaf nodes, if one of our children is a leaf
            # we are a on the min dominator boundary
            if ( $array[1] eq "32" ) {

                # Make sure we only add the node once...
                if ( ( $#minDoms == -1 ) or ( $minDoms[$#minDoms] ne $expand[$counter] ) ) {
                    push @minDoms, $expand[$counter];
                }
                $minDomFlag++;
            }
            else {

                # If we have a non leaf node as a child, we will probably
                # need to expland that child later...

                push @expand, $child;
                $expandFlag++;
            }
        }

        # corner case: if we have a non leaf child and a leaf
        # child we need to remove the non leaf child from the
        # expand list

        pop @expand if $expandFlag and $minDomFlag;
        $counter++;
    }

    print "Min Dominators:\n\n";
    foreach my $f ( @minDoms ) {
        print $f , "\n";
    }

    return;
}

__END__

=head1 SEE ALSO

L<Net::CIDR>, L<Net::IPTrie>

To join the 'perfSONAR-PS' mailing list, please visit:

  https://mail.internet2.edu/wws/info/i2-perfsonar

The perfSONAR-PS subversion repository is located at:

  https://svn.internet2.edu/svn/perfSONAR-PS

Questions and comments can be directed to the author, or the mailing list.
Bugs, feature requests, and improvements can be directed here:

  https://bugs.internet2.edu/jira/browse/PSPS

=head1 VERSION

$Id$

=head1 AUTHOR

Jason Zurawski, zurawski@internet2.edu

=head1 LICENSE

You should have received a copy of the Internet2 Intellectual Property Framework
along with this software.  If not, see
<http://www.internet2.edu/membership/ip.html>

=head1 COPYRIGHT

Copyright (c) 2008-2009, Internet2

All rights reserved.

=cut
}}}

=== Criticisms (From the Author and Others) ===

 # _K_ dominator selection is arbitrary
   * Yes, my initial decision was based on _*this looks correct*_ instead of some heuristic.
   * It would be nice to define such a heuristic
   * Need to consider the _weight_ of leaves under a given CIDR node, this can effect if we choose it
 # Trie construction only considers _shared_ CIDR ranges
   * I think this is mostly correct, but we may want to consider the _weight_ (see above) and how it effects other nodes in the tree.
 # Pruning the trie is not _destructive_
   * Implement something that allows pruning to remove some ranges and replace it with other, possibly tighter and unrelated ranges.

== Proposal ==

The proposed changes should address the overall algorithm (evaluate for correctness and completeness - compete with other attempts).  Once an suitable algorithm is found in experimentation and verified in testing, the final result will be installed into gLS and tested in a distributed environment (e.g. [https://www.planet-lab.org/ PlanetLab]).  

This work should be done primarily by the student, with help from:

 * Jason - Current Algorithm/Perl/gLS
 * Martin - Current Algorithm/Research Aspects
 * Brian T - Testing
 * Jeff - Current Algorithm/Resources
 * Aaron - Topology Considerations

=== Proposed Data Sets ===

Jason will provide the means to get _*lots*_ of datasets to test with.  

=== Proposed Algorithm ===

TBD

=== Proposed Implementation ===

Must be in Perl.  We will not be supporting the Java implementation directly.  The subsequent perl version can be translated by external programmers.  

== Project Management ==

Most details TBD, basic outline:


|| _*Dates*_ || _*Task*_ || _*People*_ ||
|| Weekly || Conference Call - Discuss progress || Jason, Martin, Student (Jeff) || 
|| March 9th - 13th || Evaluate, Learn Current Alg - Identify Failure Points || Student (Martin, Jason) || 
|| March 16th - 20th || Propose Changes (in writing), Experiment on Hypothesis (in code), Publish Results (in writing) || Student (Martin, Jason) || 
|| March 23rd - 27th || Finalize Code in prototype, integration into gLS || Student, Jason (Martin) || 
|| March 30th - April 10th || Planet Lab Beta Testing - Construct Testbed? || Student, Brian T, Jason (Jeff, Martin) || 
|| Late April || Slack time, Member Meeting, Beta Release of New Code || All || 


=== Actions ===

 * JZ 
   * Gather Datasets
   * Assist student in any and all tasks
   * gLS Integration
   * Final report on tasks
 * MS
   * Supervise student
   * weekly reports
   * Assist in researching proper algorithms
   * review progress of performance/effectiveness
 * Student
   * Review existing design of algorithm and source code
   * Propose changes to algorithm
   * Implement changes (several prototypes) in source code
   * Experimentation on data sets
   * Evaluation of results (correctness, speed, effectiveness)
   * Final source code review
   * Assist Jason in gLS integration
   * Assist Brian/Jason in test framework design, installation, testing
   * Final report on tasks
 * BT
   * Review current gLS design (April timeframe) 
   * Assist student in designing test framework
   * Assist student in framework deployment
 * AB
   * Review current gLS design (April timeframe) 
   * Think about impact of topology in summarization
 * JB
   * Review current gLS design (April timeframe) 
 == Last Modified ==$Id$ 
