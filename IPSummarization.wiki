#summary IP Summarization Algorithm in Perl

<wiki:toc max_depth="6" />

== Introduction ==

The effective and efficient summarization of the IPv4 (and eventually IPv6) address space is paramount for the Information services of perfSONAR.  The current algorithm has been the mainstay since advent of the gLS, and may take liberties with the final output:

 * Summarization is not as _tight_ as possible.  For instance given several addresses that share an A class subnet (e.g. 192.168.0.56, 192.168.48.98, 192.168.48.197) a larger than required CIDR recommendation is made: 192.0.0.0/8.  
 * Multiple ranges may confuse the overall output.  If two primary ranges are seen, 192.168.0.0/16 and 10.10.0.0/16, the recommendation may be returned that is even greater, e.g. 0.0.0.0/0.

Implementations should also consider:

 * Efficiency for input size
 * Internal data structures, such as IPTrie.  
 
The following document describes the current state of the algorithm and then lays out recommendations for upgrade as well as a work plan.  Schedules are not exact.

== Current ==

The current algorithm was developed by Jason and Martin in the Spring/Summer of 2008.  This culminated in the release of the perfSONAR-PS gLS for June of 2008.  

=== Current Algorithm ===

This algorithm makes heavy use of the concept of an IPTrie data structure.  A basic description follows:

 # Read in complete list of IP addresses.  For a given hLS the pattern should be similar to:
   * Many distinct addresses in a certain range (e.g. an SNMP MA is deployed in a single domain).
   * Potentially several ranges (if the hLS is shared)
   * _Outliers_, this is seen for point to point services such as _PingER_ and _perfSONAR-BUOY_
 # Given our list of IP addresses we need to groom the data.
   * CIDR Summarization (using [http://search.cpan.org/dist/Net-CIDR/CIDR.pm Net::CIDR]).  We really want to get _*all*_ CIDR summaries for any IP Address (simply put, what _range_ is a given IP address valid in). An Example using _*128.4.133.164*_.  A complete list of CIDR descriptions follows:
{{{
       128.4.133.164/32
       128.4.133.164/31
       128.4.133.164/30
       128.4.133.160/29
       128.4.133.160/28
       128.4.133.160/27
       128.4.133.128/26
       128.4.133.128/25
       128.4.133.0/24
       128.4.132.0/23
       128.4.132.0/22
       128.4.128.0/21
       128.4.128.0/20
       128.4.128.0/19
       128.4.128.0/18
       128.4.128.0/17
       128.4.0.0/16
       128.4.0.0/15
       128.4.0.0/14
       128.0.0.0/13
       128.0.0.0/12
       128.0.0.0/11
       128.0.0.0/10
       128.0.0.0/9
       128.0.0.0/8
       128.0.0.0/7
       128.0.0.0/6
       128.0.0.0/5
       128.0.0.0/4
       128.0.0.0/3
       128.0.0.0/2
       128.0.0.0/1
       0.0.0.0/0
}}}
   * The next step involves looking at these numbers for _all_ IP addresses that we started with.  For lack of a better term I refer to this as _*voting*_.  We keep a running tally of how many of the starting addresses share the common ancestors of CIDR descriptions.  An example using _*128.4.40.17*_ and _*128.4.133.164*_.  These addresses share the following CIDR ranges, with the _tightest_ being at the top.
{{{
       128.4.0.0/16
       128.4.0.0/15
       128.4.0.0/14
       128.0.0.0/13
       128.0.0.0/12
       128.0.0.0/11
       128.0.0.0/10
       128.0.0.0/9
       128.0.0.0/8
       128.0.0.0/7
       128.0.0.0/6
       128.0.0.0/5
       128.0.0.0/4
       128.0.0.0/3
       128.0.0.0/2
       128.0.0.0/1
       0.0.0.0/0
}}}
 # Next we need to make the IPTrie (e.g. Patricia Trie - we use the [http://search.cpan.org/~cvicente/Net-IPTrie-v0.4/lib/Net/IPTrie.pm Net::IPTrie] module).  Making the Trie consists of:
   # Insert all of the original addresses into the Trie with a /32 prefix.  This does not need to be done in order.
   # Insert all of the _voted_ and shared CIDR ranges _*in order, from most to least*_.  The ordering matters here for Trie construction.
 # After we have our Trie we have the option of _pruning_ it to remove dead ends
 # Finally we do a walk of the Trie to print out (for Graphical Purposes) and to establish:
   # _*Maximum Dominator*_ - Find the _tightest_ CIDR range for all inputs
   # _*K Dominators*_ - Walk _down the tree_, towards the leaves, and find the _K_ dominators that still describe all leaves in the _tightest_ possible manner.
 
=== Example ===

Consider this input set of data, representative of some service:

{{{
    128.175.13.92
    128.175.13.74
    128.4.40.10
    128.4.40.12
    128.4.40.17
    128.4.131.23
    128.4.133.167
    128.4.133.163
    128.4.133.164
}}}

When all is said and done, we are left with the following Trie (when using the above algorithm:

http://perfsonar-ps.googlecode.com/svn/wiki/IPSummarization/graph.png

The top CIDR, _*128.0.0.0/8*_, dominates all leaves and is as _tight_ as possible.   To select the _K_ dominators we can craft an arbitrary rule to _slice_ off portions of the tree that directly touch a leaf:

http://perfsonar-ps.googlecode.com/svn/wiki/IPSummarization/graph2.png

This allows us to choose 3 dominators:
{{{
    128.175.13.64/27
    128.4.128.0/21
    128.4.40.0/27
}}}

=== Current Implementation ===

The following is a short script that implements the above algorithm.  It is written in perl and currently present in all production gLS instances.  Comments are inserted where obvious changes to the algorithm were made.  Important deviations:

 # The IPTrie object is not sound.  Modifications to the Trie are required after construction to properly link the pointers of children and parents.  For this reason we may wish to implement our own IPTrie.  It remains because it does offer some useful functions (e.g. printing out the Trie)
 # Voting is rather simple.  We simply rank by shared parent
 # Graphviz notation provided to make pretty pictures.

{{{
#!/usr/bin/perl -w

use strict;
use warnings;

=head1 NAME

ipTree.pl - Utility to demonstrate the effectivness of CIDR summarizations of
IP addresses as well as a potential solution to finding dominating values
when used in a Radix Tree (Patricia Trie) data structure.

=head1 USAGE

  perl ipTree.pl

An outputed list of the minimum dominators of the resulting IPTrie will be
be displayed.  This will generate a graphviz .dot file (graph.dot) of the
IPTrie that can then be used with the graphviz executable:

  dot graph.dot -Tpng -o graph.png

=head1 DESCRIPTION

The perfSONAR dLS and gLS require a way to summarize large amounts of
topological data (namely IP addresses of type IPv4 and IPv6).  Using the
well known CIDR way of specificying IP address ranges, this simple script aims
to combine the 'dominating' (i.e. greatest available CIDR summaries) for some
set of source IP addresses.

The output is placed into a graphviz dot file for display.

=cut

use Net::CIDR ':all';
use Net::IPTrie;
use Data::Dumper;

# IP Trie Data Structure (similar to Net::Patricia)
my $tr = Net::IPTrie->new( version => 4 );

# I need to be able to do my own manipulations (e.g. IPTrie is not really
# that great...)
my %tree = ();

# Ensure that each child only has one parent (IPTrie data structure
# uses a strange internal representation).
my %claim = ();

# starting list of IPs

my @map = ( "128.175.13.92", "128.175.13.74", "128.4.40.10", "128.4.40.12", "128.4.40.17", "128.4.131.23", "128.4.133.167", "128.4.133.163", "128.4.133.164" );

#my @map = ("150.254.160.194",
#           "150.254.160.195",
#           "150.254.160.196",
#           "120.10.0.11",
#           "120.10.0.12",
#           "120.10.0.17",
#           "120.11.5.1",
#           "120.11.5.2",
#           "80.15.11.2",
#           "80.15.11.3");

#my @map = ("64.57.25.15",
#           "64.57.27.4",
#           "64.57.27.138",
#           "128.4.12.12",
#           "128.4.13.1",
#           "160.135.1.1",
#           "207.75.165.151",
#           "207.72.226.18",
#           "206.72.224.1");

my $vote = getCDIRSummaries( \@map );
$tr = makePatriciaTrie( \@map, $vote, $tr );
manipulatePatriciaTrie( \@map, $tr );
genGraph( \%tree );
listMinDoms();

exit( 1 );

=head2 getCDIRSummaries($map)

Given a list of IP addresses, gather the CIDR representations then 
group this by a popularity ranking (i.e. if there are 9 hosts, and 9
have a set grouping of CIDR values in common, this is a dominator).

=cut

sub getCDIRSummaries {
    my ( $map ) = @_;

    my %tally = ();
    foreach my $host ( @{$map} ) {
        my @list = Net::CIDR::addr2cidr( $host );
        foreach my $range ( @list ) {

            # we want to ingore the wildcard addresses...
            next if $range =~ m/^0\./;

            $tally{$range}++ if defined $tally{$range};
            $tally{$range} = 1 if not defined $tally{$range};
        }
    }

    return \%tally;
}

=head2 makePatriciaTrie($map, $votes, $tr)

Creates the initial IPTrie structure using the list of 
available hosts (e.g. $map) and the CIDR values for
each (ranked into popularity groups).  The end result is
the IPTrie.

=cut

sub makePatriciaTrie {
    my ( $map, $tally, $tr ) = @_;

    # Start to make the IPTrie data structure.  First we add in all
    # of the 'base' addresses

    foreach my $host ( @{$map} ) {
        $tr->add( address => $host, prefix => "32" );
    }

    # Now we add in the summaries.

    foreach my $t ( sort keys %{$tally} ) {
        my @parts = split( /\//, $t );
        $tr->add( address => $parts[0], prefix => $parts[1] );
    }

    return $tr;
}

=head2 extract($parent, $node, $status, $side)

This aux function recursively walks the nodes of the IPTrie structure
and creates a more usefriendly tree that we will use for manipulation
and final display.

=cut

sub extract {
    my ( $parent, $node, $status, $side ) = @_;
    my $me = "";
    $me = $node->[3] . "/" . $node->[5] if defined $node->[3] and defined $node->[5];
    if ( $me and $side and ( not $claim{$me} ) ) {
        push @{ $tree{$parent}{"C"} }, $me;
        $claim{$me} = 1;
    }
    $status = extract( $parent, $node->[1], $status, "L" ) if $node->[1] and ( not $status->{"L"} );
    $status = extract( $parent, $node->[2], $status, "R" ) if $node->[2] and ( not $status->{"R"} );
    return $status;
}

=head2 manipulatePatriciaTrie($tr)

Given the IPTrie structure, we need to manually manipulate the nodes into
our own format.

=cut

sub manipulatePatriciaTrie {
    my ( $map, $tr ) = @_;

    my $list  = ();
    my $code  = sub { push @$list, shift @_; };
    my $count = $tr->traverse( code => $code );

    # hacky root pointer (gives us unification if the whild card [0.*]
    # was really needed)

    my @temp = ();
    $tree{"Root"}{"C"} = \@temp;
    $tree{"Root"}{"U"} = "NULL";

    # we need to go backwards when looking at the IPTrie print out, this is
    # is really to be sure children aren't all claimed by the root (the internal
    # structure is a little strange) so this ensures we hit the root last.

    foreach my $node ( reverse @{$list} ) {
        my $me = "";
        $me = $node->[3] . "/" . $node->[5] if defined $node->[3] and defined $node->[5];
        next unless $me;

        # each one of our node-keys has some location information
        my @temp = ();
        $tree{$me}{"C"} = \@temp;
        $tree{$me}{"U"} = "";

        # recursively search the tree, stop after you find a left and right
        # child though (N.B. this creates problems unfortunately, so we need
        # to manually manipulate...)
        my %status = (
            "L" => 0,
            "R" => 0
        );
        extract( $me, $node, \%status, "" );
    }

    # link all the parent information for each node and child

    foreach my $item ( keys %tree ) {
        foreach my $c ( @{ $tree{$item}{"C"} } ) {
            $tree{$c}{"U"} = $item if $c and $item;
        }
    }

    # First step: Start at the leaves and walk toward the root.
    # - Every time we see a node with a sinle child, collapse it into the parent
    #   (we are pruning the tree)

    foreach my $host ( @{$map} ) {
        my $current = $host . "/32";
        while ( $current ) {
            my $delete = "";
            if (    $#{ $tree{ $tree{$current}{"U"} }{"C"} } == 0
                and not( $current =~ m/\/32$/ )
                and $#{ $tree{$current}{"C"} } == 0 )
            {
                $delete = $current;
                foreach my $child ( @{ $tree{$current}{"C"} } ) {
                    $tree{$child}{"U"} = $tree{$current}{"U"};
                }
                $tree{ $tree{$current}{"U"} }{"C"} = $tree{$current}{"C"};
                delete $tree{$delete}{"C"};
            }
            $current = $tree{$current}{"U"};
            delete $tree{$delete} if $delete;
        }
    }

    # Second step: Start at the leaves and walk toward the root.
    # - Every time we see a single child node, collapse it into the child (this
    #   is the opposite of what we just did, but this handles branching much
    #   better, this is also a form of pruning).

    foreach my $host ( @{$map} ) {
        my $current = $host . "/32";
        while ( $current ) {
            my $delete = "";
            if ( $#{ $tree{$current}{"C"} } == 0 ) {
                $delete = $current;
                foreach my $child ( @{ $tree{$delete}{"C"} } ) {
                    $tree{$child}{"U"} = $tree{$delete}{"U"};
                    push @{ $tree{ $tree{$delete}{"U"} }{"C"} }, $child;
                }

                my $counter = 0;
                foreach my $child ( @{ $tree{ $tree{$delete}{"U"} }{"C"} } ) {
                    if ( $child eq $current ) {
                        my $remove = splice( @{ $tree{ $tree{$delete}{"U"} }{"C"} }, $counter, 1 );
                    }
                    $counter++;
                }
            }
            $current = $tree{$current}{"U"};
            delete $tree{$delete} if $delete;
        }
    }

    # finally link the tree(s) to the root pointer

    foreach my $node ( keys %tree ) {
        unless ( $tree{$node}{"U"} ) {
            $tree{$node}{"U"} = "Root";
            push @{ $tree{"Root"}{"C"} }, $node;
        }
    }

    return;
}

=head2 genGraph

Outputs the contents of the tree structure into a "Graphviz" formated
DAG file.  

=cut

sub genGraph {

    open( DOT, ">graph.dot" );
    print DOT "digraph g {\n";

    foreach my $item ( keys %tree ) {
        next unless $item;
        if ( $item =~ m/\/\d+$/ ) {
            my @array = ();
            @array = split( /\//, $item );

            # color the terminal elements so we know they are not dominators
            if ( $array[1] eq "32" ) {
                print DOT "\t\"", $item, "\"[ color=crimson, style=filled ];\n";
            }
            else {
                print DOT "\t\"", $item, "\";\n";
            }
        }
        else {

            # this is the root...

            print DOT "\t\"", $item, "\"[ color=yellow, style=filled ];\n";
        }
    }

    # output the linkings

    foreach my $item ( keys %tree ) {
        next unless $item;
        foreach my $c ( @{ $tree{$item}{"C"} } ) {
            next unless $c;
            print DOT "\t\"", $item, "\" -> \"", $c, "\";\n";
        }
    }

    print DOT "}\n";
    close( DOT );
    return;
}

=head2 listMinDoms

Given the tree, 'slice off' the top level of nodes that are
not necessarily representative of the domination (e.g. if they
are just used to direct traffic through the tree, and do not
have direct /32 children).  We return a list of nodes that
represent the minimum set of addresses that can be used to
describe any of the originals.

=cut

sub listMinDoms {

    # First locate the root in the tree

    my @expand = ();
    foreach my $node ( sort keys %tree ) {
        if ( $node and $tree{$node}{"U"} eq "Root" ) {

            # add the root the 'expand' list so we can
            # examine it (and it's children, etc.) then
            # exit
            push @expand, $node;
        }
    }

    my $counter = 0;
    my @minDoms = ();

    # now we are going to walk the tree.  If a non-leaf
    # node has two non-leaf children is is useless to us,
    # so we skip it.  If a non-leaf node has at least one
    # leaf child, this is a part of our 'boundary' so
    # we list it as a minDominator.

    while ( $expand[$counter] ) {
        my $minDomFlag = 0;
        my $expandFlag = 0;

        foreach my $child ( sort @{ $tree{ $expand[$counter] }{"C"} } ) {
            my @array = split( /\//, $child );

            # /32's are leaf nodes, if one of our children is a leaf
            # we are a on the min dominator boundary
            if ( $array[1] eq "32" ) {

                # Make sure we only add the node once...
                if ( ( $#minDoms == -1 ) or ( $minDoms[$#minDoms] ne $expand[$counter] ) ) {
                    push @minDoms, $expand[$counter];
                }
                $minDomFlag++;
            }
            else {

                # If we have a non leaf node as a child, we will probably
                # need to expland that child later...

                push @expand, $child;
                $expandFlag++;
            }
        }

        # corner case: if we have a non leaf child and a leaf
        # child we need to remove the non leaf child from the
        # expand list

        pop @expand if $expandFlag and $minDomFlag;
        $counter++;
    }

    print "Min Dominators:\n\n";
    foreach my $f ( @minDoms ) {
        print $f , "\n";
    }

    return;
}

__END__

=head1 SEE ALSO

L<Net::CIDR>, L<Net::IPTrie>

To join the 'perfSONAR-PS' mailing list, please visit:

  https://mail.internet2.edu/wws/info/i2-perfsonar

The perfSONAR-PS subversion repository is located at:

  https://svn.internet2.edu/svn/perfSONAR-PS

Questions and comments can be directed to the author, or the mailing list.
Bugs, feature requests, and improvements can be directed here:

  https://bugs.internet2.edu/jira/browse/PSPS

=head1 VERSION

$Id$

=head1 AUTHOR

Jason Zurawski, zurawski@internet2.edu

=head1 LICENSE

You should have received a copy of the Internet2 Intellectual Property Framework
along with this software.  If not, see
<http://www.internet2.edu/membership/ip.html>

=head1 COPYRIGHT

Copyright (c) 2008-2009, Internet2

All rights reserved.

=cut
}}}

=== Criticisms (From the Author and Others) ===

 # _K_ dominator selection is arbitrary
   * Yes, my initial decision was based on _*this looks correct*_ instead of some heuristic.
   * It would be nice to define such a heuristic
   * Need to consider the _weight_ of leaves under a given CIDR node, this can effect if we choose it
 # Trie construction only considers _shared_ CIDR ranges
   * I think this is mostly correct, but we may want to consider the _weight_ (see above) and how it effects other nodes in the tree.
 # Pruning the trie is not _destructive_
   * Implement something that allows pruning to remove some ranges and replace it with other, possibly tighter and unrelated ranges.

== Proposal ==

The proposed changes should address the overall algorithm (evaluate for correctness and completeness - compete with other attempts).  Once an suitable algorithm is found in experimentation and verified in testing, the final result will be installed into gLS and tested in a distributed environment (e.g. [https://www.planet-lab.org/ PlanetLab]).  

This work should be done primarily by the student, with help from:

 * Jason - Current Algorithm/Perl/gLS
 * Martin - Current Algorithm/Research Aspects
 * Brian T - Testing
 * Jeff - Current Algorithm/Resources
 * Aaron - Topology Considerations

=== Proposed Data Sets ===

Jason will provide the means to get _*lots*_ of datasets to test with.  

=== Proposed Algorithm ===

The proposed algorithm works as follows.

Given a list of IP numbers, create a [http://en.wikipedia.org/wiki/Patricia_tree Patricia Tree] (or simply [http://en.wikipedia.org/wiki/Trie Trie]) and iterate over the list, inserting each IP number into the trie.  The trie data structure will automatically create inner nodes which correspond to the (candidate) summarization nodes, or CIDR classes.

When a node is created into the trie, two values are calculated and attached to the node:  the _coverage_ and the _childCount_.

The _childCount_ is the number of descendants below a node.  Or, in other words, the number of nodes within the subtrees deriving from that node.  Every time a node is added to the trie, its ancestors also have this value updated.

The _coverage_ is a measure of the density of number of desdendants of the node over the maximum possible number of hosts below the node.  The idea here is that, if below a node, there can exist a maximum of 32 hosts, but actually there exists only one, then the density of hosts below that node is low.  If there can exist a maximum of 32 hosts, and there are actually 32 hosts below the node, then the density is high (or maximal in this case).  The number of maximum hosts below a node is calculated as:

    `$self->{coverage} =  $self->{childCount} / (2**(MAX_KEY_LENGTH - $self->{mask}));`
	
where MAX_KEY_LENGTH is typically 32, the _mask_ is the CIDR class (number after the / in the IP number), and _childCount_ is the number of desdendants (calculated as above).  The meaning of this equation is:  MAX_KEY_LENGTH - _mask_ yields the number of bits available, in the range of IP addresses, to be assigned to hosts.  Raising 2 to this power results in the equivalent number of hosts available within this range of IP addresses.  Dividing the actual number of desdendants by the number of (maximum) available hosts yields the density, or coverage.  This coverage value is also updated as new nodes are added to the trie.

Once created, recurse down the trie, starting from the root node (the root node should be the looser, or larger, summarization IP number; in a worst case, it would be 0.0.0.0/0).  At each internal node, evaluate whether the trie should continue to be recursed down, or whether it should be pruned, and the corresponding node is then marked as a summarization node.  The decision of whether to mark a summarization node is done in the method _markIpTrie1_, shown below:


{{{
sub markIpTrie1 {
	my $self = shift;
	my ($summaryArrayListref, $node) = @_;
	
	my @summaryArrayList = @$summaryArrayListref;
	
	my $c0n = $node->{childZero};
	my $c1n = $node->{childOne};
		
		if(!(defined $c0n)) {
			
			$node->setSummaryMember();
			push(@summaryArrayList, $node);
		
		}elsif(defined $c0n &&
				($c0n->{mask} - $node->{mask} > 8) || 
				($c1n->{mask} - $node->{mask} > 8) || 
				($node->{coverage} < 0.000001) ) {
					
			@summaryArrayList = $self->markIpTrie1(\@summaryArrayList, $c0n);
			@summaryArrayList = $self->markIpTrie1(\@summaryArrayList, $c1n);
		}
		else {
			$node->setSummaryMember();
			push(@summaryArrayList, $node);
		}
		
		return @summaryArrayList;
	}
	
}}}

Basically, both children of a node are evaluated for the following conditions:

    _!ChildMask_ - _!NodeMask_ > 8

    _Node Coverage_ < 0.000001 (i.e., low density)

If either is satisfied, then the program will recurse down the subtrees below the current node and perform the same tests on the descendants.  If none of the conditions is satisfied, then the current node is marked as a summarization node and the subtrees below this node will not be further analyzed.

The heuristic used for this decision is based on the _distance_ between an internal node and its children, and the coverage or density.  The _distance_ value expresses the number of CIDR classes between the current node and its child; basically, it conveys the notion whether the current node represents a too large subnet to be considered for summarization.  For example, consider that the current node has a mask of 20 and its child has a mask of 32.  Then the current node represents a subclass of 4096 hosts (12 bits), so there's a possibility of having a substantial amount of nodes below the current node.  The algorithm then decides to recurse down the subtree.  Conversely, if the distance is short, then the current node may already comprise sufficient information to be selected as a summarization node.

The reasoning for the coverage or density tries to gather whether there exists already a relevant number of descendants for the current node; if there is, then it may be convenient to select the current node as a summarization node.

==== Subsequent Work ====

The algorithm is to be further optimized to allow for tuning of its heuristics, and to possibly incorporate the notion of weight of the subtrees.


=== Proposed Implementation ===

Must be in Perl.  We will not be supporting the Java implementation directly.  The subsequent perl version can be translated by external programmers.

==== Class !IpTrie.pm ====

{{{
package IpTrie;

use strict;
use warnings;

use constant MAX_KEY_LENGTH => 32;

sub new {
	shift;
	my ( $t ) = @_;

	my $self = {};
	$self->{trie} = $t;
	$self->{nodeList} = ();
	$self->{root} = undef;
	
	bless($self);
	
	$self->updateNodelist();
	if ($self->{root}->{childCount} != $self->{trie}->getCount()) {
			print "Trie count != root IpTrieNode count";
			exit(-1);
	}
	
	return $self;
}

	
# this method walks the base Trie and fills in IpTrieNodes
sub updateNodelist {
	my $self = shift;
	$self->{nodeList} = ();
	my $startPosition = MAX_KEY_LENGTH;
	my $startKey = 0;
	$self->{root} = IpTrieNode->new($self->{trie}->getRootNode(), $startPosition, $startKey);
	push(@{$self->{nodeList}}, $self->{root});
	$self->walkTree($self->{root}, $startPosition, $startKey);
}
	
#walk the tree from node down
sub walkTree {
	my $self = shift;
	my ( $node, $position, $currentKey ) = @_;
		
	my $tnode = $node->{trieNode};
	my $c0 = $tnode->getChildZero();
	my $c1 = $tnode->getChildOne();
		
	if (defined $c0) {
    	my $c0Key = $c0->getKey() << ($position - $c0->getKeyLength());
    	my $c0Position = $position - $c0->getKeyLength();
    	$c0Key = $c0Key | $currentKey;
    	my $c0ipTrieNode = IpTrieNode->new($c0, $c0Position, $c0Key);
    	push(@{$self->{nodeList}}, $c0ipTrieNode);
    	$node->setChildZero($c0ipTrieNode);
    	$c0ipTrieNode->setParent($node);
    	$self->walkTree($c0ipTrieNode, $c0Position, $c0Key);

    }
    if ( defined $c1) {
    	my $c1Key = $c1->getKey() << ($position - $c1->getKeyLength());
    	my $c1Position = $position - $c1->getKeyLength();
    	$c1Key = $c1Key | $currentKey;
    	my $c1ipTrieNode = IpTrieNode->new($c1, $c1Position, $c1Key);
    	push(@{$self->{nodeList}}, $c1ipTrieNode);
    	$node->setChildOne($c1ipTrieNode);
    	$c1ipTrieNode->setParent($node);
    	$self->walkTree($c1ipTrieNode, $c1Position, $c1Key);
    }

}
	
sub getNodes {
	my $self = shift;
	return $self->{nodelist};
}
	
sub getInternalNodes {
	my $self = shift;
	my @alitn = ();
	for my $node ( @{$self->{nodelist}} ) {
		if (defined $node->{childZero}) {
			push(@alitn, $node);
		}
	}
	return @alitn;
}
	
sub getSummaryNodes {
	my $self = shift;
	my @alitn = ();
	
	for my $node ( @{$self->{nodelist}} ) {
			# evaluate what to return
			# here we say if the data pointer is null, but it 
			# has one child with data, then it is on the summary front
			
			# hackage for the root $node, which might have a null child
			# no other $node does
			next if (!(defined $node->{childOne} and defined $node->{childZero}));
			
			if (!(defined $node->{trieNode}->getData()) &&
				(defined $node->{childZero}->{trieNode}->getData() ||
				 defined $node->{childOne}->{trieNode}->getData()) ) {
					push(@alitn, $node);
			}
		}
		return @alitn;
}
	
sub getSummaryNodesSummaryFront {
	my $self = shift;
	my @alitn = ();
	
	for my $node ( @{$self->{nodelist}} ) {
			# evaluate what to return
			# here we say if the data pointer is null, but it 
			# has one child with data, then it is on the summary front
			
			# hackage for the root $node, which might have a null child
			# no other $node does
			next if (!(defined $node->{childOne} and defined $node->{childZero}));
			
			if (!(defined $node->{trieNode}->getData()) &&
				(defined $node->{childZero}->{trieNode}->getData() ||
				 defined $node->{childOne}->{trieNode}->getData() ) ) {
					push(@alitn, $node);
			}
		}
		
	my @alitn2 = ();
	for my $node ( @alitn ) {
			if( ($node->{mask} - $node->{parent}->{mask}) > 2) {
				push(@alitn2, $node);
			}
		}
		
		#sanity check
		my $sum = 0;
		for my $node ( @alitn2 ) {
			print $node->{addrString}." ".$node->{childCount};
			$sum += $node->{childCount};
		}
		
		if ($sum != $self->{trie}->getCount()) {
			print "sum, nodeCount ".$sum." ".$self->{trie}->getCount();
			print "Heuristic failed!";
			@alitn2 = ();
		}
		return @alitn2;
	}	
	
sub getSummary {
	my $self = shift;
		my @alitn = ();
		if (defined $self->{root}->{childZero}) {
			@alitn = $self->markIpTrie1(\@alitn, $self->{root}->{childZero});
		}
		if (defined $self->{root}->{childOne}) {
			@alitn = $self->markIpTrie1(\@alitn, $self->{root}->{childOne});
		}
		
		#sanity check
		my $sum = 0;
		for my $node ( @alitn ) {
			$sum += $node->{childCount};
			if ($node->{mask} == 32){ $sum++ };
		}
		
		if ($sum != $self->{trie}->getCount()) {
			print "Summarization failed! (covered ".$sum."prefixes out of ".$self->{trie}->getCount().")";
			@alitn = ();
		}
		
		return @alitn;
	}
	
	# this will walk the tree and evaluate whether to continue recursing down
	# the tree or add itself to the summary list and prune the subtree.
	# 
	# approach #1
	#
sub markIpTrie1 {
	my $self = shift;
	my ($summaryArrayListref, $node) = @_;
	
	my @summaryArrayList = @$summaryArrayListref;
	
	my $c0n = $node->{childZero};
	my $c1n = $node->{childOne};
		
		if(!(defined $c0n)) {
			
			$node->setSummaryMember();
			push(@summaryArrayList, $node);
		
		}elsif(defined $c0n &&
				($c0n->{mask} - $node->{mask} > 8) || 
				($c1n->{mask} - $node->{mask} > 8) || 
				($node->{coverage} < 0.000001) ) {
					
			@summaryArrayList = $self->markIpTrie1(\@summaryArrayList, $c0n);
			@summaryArrayList = $self->markIpTrie1(\@summaryArrayList, $c1n);
		}
		else {
			$node->setSummaryMember();
			push(@summaryArrayList, $node);
		}
		
		return @summaryArrayList;
	}

sub printDot {
	my $self = shift;
	my ($fileName) = @_;
	my $file;
	
	open ($file, "> ".$fileName) or die $!;

    print $file "digraph g {\n";
    $self->printDotNode($file, $self->{root});
    print $file "}\n";

    close $file;
}
	
sub printDotNode {
	my $self = shift;
	my ($file, $node) = @_;
		
	my $coverageString = sprintf("%.6f", $node->{coverage});
		
	my $nodeString = "\"".$node->{addrString}."\" [";
		
	if($node->{summaryMember}) {
			$nodeString .= "style=filled,fillcolor=lightslategray,";
		}
	elsif($node->{isInternal}) {
		$nodeString .= "style=filled,";
	}
		
	$nodeString .= "shape=record,label=\"<f0>".$node->{addrString}
		. "|<f1>" . $node->{childCount}
		. "|<f2>" . $coverageString
		. "\"]";
	print $file $nodeString."\n";
	
		if (defined $node->{childZero}) {
			my $edgeZeroString = "\"".$node->{addrString}."\" -> \""
			. $node->{childZero}->{addrString}."\"";
			$edgeZeroString .= "[label=".($node->{childZero}->{mask} - $node->{mask})."];";
			print $file $edgeZeroString."\n";
			$self->printDotNode($file, $node->{childZero});
		}
		
		if (defined $node->{childOne}) {
			my $edgeOneString = "\"".$node->{addrString}."\" -> \""
			. $node->{childOne}->{addrString}."\"";
			$edgeOneString .= "[label=".($node->{childOne}->{mask} - $node->{mask})."];";
			print $file $edgeOneString."\n";
			$self->printDotNode($file, $node->{childOne});
		}
	}

	1;
}}}  

==== Class !IpTrieNode.pm ====

{{{
package IpTrieNode;

use strict;
use warnings;

use constant MAX_KEY_LENGTH => 32;

sub longToIP {
	shift;
	my ($ipInLong) = @_;

    my $ipAddress = "";
    my @ipArrayInLong;
    my $num;

    for (my $i = 0; $i < 4; $i++) {

      my $factor = (256 ** (4 - $i - 1));
      $num = $ipInLong / $factor;
      $num =~ s/\.[0-9]*//;
      $ipInLong = $ipInLong - ($num * $factor);
      if ($num > 255) {
          print "Invalid CONVERSION";
      }
      
      $ipArrayInLong[$i] = $num;
           $ipAddress .= $ipArrayInLong[$i];
            if ($i != 3) {
                $ipAddress .= ".";
            }
        }
        return $ipAddress;
    }
    
sub new {
	shift;
	my ( $tnode, $position, $currentKey ) = @_;

	my $self = {};
	$self->{mask} = MAX_KEY_LENGTH - $position;
	$self->{ipAddress} = undef;
	$self->{key} = $currentKey;
	$self->{keyString} = IpTrieNode->longToIP($self->{key});
	$self->{addrString} = $self->{keyString}."/".$self->{mask};
	$self->{trieNode} = $tnode;
	$self->{parent} = undef;
	$self->{childZero} = undef;
	$self->{childOne} = undef;
	$self->{childCount} = $tnode->getChildCount();
	$self->{summaryMember} = 0;
	$self->{isInternal} = undef;
	$self->{coverage} = undef;

	if ($self->{mask} == MAX_KEY_LENGTH) { 
		$self->{coverage} = 1.0;
	}
	else {
			$self->{coverage} =  $self->{childCount} / (2**(MAX_KEY_LENGTH - $self->{mask}));
		}
		if(!(defined $tnode->getData())) {
			$self->{isInternal} = 1;
		}
		else {
			$self->{isInternal} = 0;
		}

	bless($self);
	return $self;
}

	
sub setSummaryMember {
	my $self = shift;
	$self->{summaryMember} = 1;	
}
	
sub isSummaryMember {
	my $self = shift;
	return $self->{summaryMember};
}
	
sub setParent {
	my $self = shift;
	my ($newParent) = @_;
	
	$self->{parent} = $newParent;
	return $self;
}
	
sub setChildZero {
	my $self = shift;
	my ($newChild) = @_;
	
	$self->{childZero} = $newChild;
	return $self;
}
	
sub setChildOne {
my $self = shift;
	my ($newChild) = @_;
	
	$self->{childOne} = $newChild;
	return $self;
}

1;
}}}

==== Class Trie.pm ====

{{{
package Trie;

use strict;
use warnings;

use constant MAX_KEY_LENGTH => 32;

    
sub new {
	shift;
	my ( $rootnode ) = @_;

	my $self = {};
	$self->{nodeCount} = undef;
	$self->{keyList} = ();
	$self->{rootNode} = $rootnode;

	bless($self);
	return $self;
}

sub getKeyList {
	my $self = shift;
    return $self->{keyList};
}

sub getRootNode {
	my $self = shift;
    return $self->{rootNode};
}
    
sub firstDigit {
	shift;
	my ( $key, $keyLength ) = @_;
	return ( $key >> ( $keyLength - 1 ) ) & 1;
}

sub Add {
	my $self = shift;
	my ( $key, $keyLength, $data ) = @_;
       
    $self->{nodeCount}++;
    $self->{rootNode}->incrementChildCount();
        
        if (Trie->firstDigit($key, $keyLength) == 1) {
            if (defined $self->{rootNode}->getChildOne()) {
                $self->{rootNode}->getChildOne()->Add($key, $keyLength, $data);
            }
            else {
                $self->{rootNode}->setChildOne(TrieNode->new($key, $keyLength));
                $self->{rootNode}->getChildOne()->setData($data);
            }
        } else {
            if (defined $self->{rootNode}->getChildZero()) {
                $self->{rootNode}->getChildZero()->Add($key, $keyLength, $data);
            }
            else {
                $self->{rootNode}->setChildZero(TrieNode->new($key, $keyLength));
                $self->{rootNode}->getChildZero()->setData($data);
            }
        }
        return $self;
    }

sub FindExactMatch {
	my $self = shift;
	my ( $key, $keyLength ) = @_;
	
        if (Trie->firstDigit($key, $keyLength) == 1){
        	if(defined $self->{rootNode}->getChildOne() 
            	&& $self->{rootNode}->getChildOne()->FindExactMatch($key, $keyLength)){
  				return 1;          		
            }else{
            	return 0;
            }
        }
        else{
            if(defined $self->{rootNode}->getChildZero() 
            	&& $self->{rootNode}->getChildZero()->FindExactMatch($key, $keyLength)){
  				return 1;          		
            }else{
            	return 0;
            }
        }
    }

sub Merge {
	my $self = shift;
	my ( $trie ) = @_;
	
    my @keys = $trie->GetKeys();
    for my $key (@keys){
            $self->Add($key, MAX_KEY_LENGTH, undef);
	}
        return $self;
}

sub GetKeys() {
	my $self = shift;
	
	unless(@_){
		#no parameters version
		my $key = 0;
        my $position = MAX_KEY_LENGTH;
        my @keys = ();

        if (defined $self->{rootNode}->getChildZero()){
            @keys = $self->GetKeys(\@keys, $self->{rootNode}->getChildZero(), $key, $position);
        }
        if (defined $self->{rootNode}->getChildOne()){
            @keys = $self->GetKeys(\@keys, $self->{rootNode}->getChildOne(), $key, $position);
        }
        return @keys;
	}
        
    #version with parameters
    my ($keysref, $node, $key, $position ) = @_;
    my @keys = @$keysref;
    
    $key = $key | ($node->getKey() << ($position - $node->getKeyLength()));

        if (defined $node->getChildZero()){
        	@keys = $self->GetKeys(\@keys, $node.getChildZero(), $key, $position - $node->getKeyLength());
        }
           
        if (defined $node->getChildOne()){
            @keys = $self->GetKeys(\@keys, $node.getChildOne(), $key, $position - $node->getKeyLength());
        }
        for (my $i = 0; $i < $node->getValueCount(); $i++) {
            push(@keys, $key);
        }
        return @keys;
    }

    #returns the best match of keys for the given inputs
sub FindBestMatch {
	my $self = shift;
	my ( $key, $keyLength ) = @_;
       
        #implements the best match by digging all the way to the leaf based on the $key difference.
        if (Trie->firstDigit($key, $keyLength) == 1) {
            if (defined $self->{rootNode}->getChildOne()){
                return $self->{rootNode}->getChildOne()->FindBestMatch($key, $keyLength);
            }
            else{
                return undef;
            }
        } elsif (!(defined $self->{rootNode}->getChildZero())){
        	return undef;
        }
        return $self->{rootNode}->getChildZero()->FindBestMatch($key, $keyLength);
    }

sub Equals {
	my $self = shift;
	my ( $trie ) = @_;
	
        if (defined $trie) {
            if ($self->getCount() == $trie->getCount()) {
                my @list1 = $self->GetKeys();
                my @list2 = $trie->GetKeys();

                for (my $i = 0; $i < $self->{nodeCount}; $i++) {
                    if (!($list1[$i] == $list2[$i])){
                        return 0;
                    }
                }
                return 1;
            }
        }
        return 0;
}

sub getCount {
	my $self = shift;
        return $self->{nodeCount};
    }

sub Remove {
	my $self = shift;
	
	#version with 2 parameters
	if($#_ == 2){
		my ( $key, $keyLength ) = @_;
    	my $root;

		if(Trie->firstDigit($key, $keyLength) == 1){
			$root = $self->{rootNode}->getChildOne();
		}else{
			$root =  $self->{rootNode}->getChildZero();
		}

   		if ($self->Remove($root, $key, $keyLength, 0)) {
            $self->{nodeCount}--;
            return 1;
        }
        return 0;
    }
    #version with 4 parameters
    else{
    	my ( $node, $key, $keyLength, $currentKeyLength ) = @_;
    	
    	my $success;
        my $child;

        $currentKeyLength += $node->getKeyLength();

        if ($currentKeyLength == $keyLength && $node->getKey() == ($key & 1)) {
            # by setting node.m_valueCount to -1, we indicate that it can be deleted
            if ($node->getValueCount() > 1){
                $node->setValueCount($node->getValueCount() - 1);
            }
            else {
                if (!(defined $node->getChildZero() or defined $node->getChildOne())){
                    $node->setValueCount($node->getValueCount() - 1);
                }else{
                    $node->setValueCount(0);
                }
            }
            return 1;
        } elsif (Trie->firstDigit($key, $keyLength - $currentKeyLength) == 1){
            $child = $node->getChildOne();
        } else {
            $child = $node->getChildZero();
        }

        $success = ((defined $child) && $self->Remove($child, $key, $keyLength, $currentKeyLength));

        if ($success) {
            # check if we need to delete nodes as we go back along the path
            # the node is safe to be deleted if its valueCount = -1

            if ($child->getValueCount() < 0) {
                if ($child->getKey() == 1){
                	$node->setChildOne(undef);
                }
                else{
                    $node->setChildZero(undef);
                }
                if ($node->getValueCount() == 0 && !(defined $node->getChildZero() or $node->getChildOne())){
                	$node->setValueCount(-1);
                }
            }
        }
        return $success;
    }
}

=cut

sub mostDominantKeyList {

        TrieNode childOne = $self->{rootNode}->getChildOne();
        TrieNode childZero = $self->{rootNode}->getChildZero();

        if (childOne != null) {
            mostDominantKeyList(childOne, childOne.getKey(), Constants.MAX_KEY_LENGTH);
        }
        if (childZero != null) {
            mostDominantKeyList(childZero, childZero.getKey(), Constants.MAX_KEY_LENGTH);
        }
    }

    private void mostDominantKeyList(TrieNode node, long $key, long position) {

        TrieNode childZero = $node->getChildZero();
        TrieNode childOne = $node->getChildOne();

        $key = $key | ($node->getKey() << (position - $node->getKeyLength()));
        position = position - $node->getKeyLength();
        if (childZero != null) {
            mostDominantKeyList(childZero, $key, position);
        }
        if (childOne != null) {
            mostDominantKeyList(childOne, $key, position);
        }
        if (($node->getChildOne() != null) && ($node->getChildZero() != null))
            keyList.add(TrieNode->new($key, position));
    }
    
sub printDot(String fileName) throws FileNotFoundException {
    	FileOutputStream file = new FileOutputStream(fileName);
    	PrintStream p = new PrintStream(file);
    	long position = Constants.MAX_KEY_LENGTH;
    	long currentKey = 0;
    	p.println("digraph g {");
    	$self->{rootNode}->printDotNode(p, rootNode, position, currentKey);
    	p.println("}");
    	p.close();
    }
    
sub<String> listInternalNodes() {
    	long position = Constants.MAX_KEY_LENGTH;
    	long currentKey = 0;
    	ArrayList<String> listOfNodes = new ArrayList<String>();
    	$self->{rootNode}->listInternalNodes(listOfNodes, position, currentKey);
    	return listOfNodes;
    }
    
sub<String> listSummaryNodes() {
    	long position = Constants.MAX_KEY_LENGTH;
    	long currentKey = 0;
    	ArrayList<String> listOfNodes = new ArrayList<String>();
    	$self->{rootNode}->listSummaryNodes(listOfNodes, position, currentKey);
    	return listOfNodes;
    }
}

=cut

1;
}}}

==== Class !TrieNode.pm ====

{{{
package TrieNode;

use strict;
use warnings;

sub new {
	shift;
	my ( $key, $keyLength, $valueCount ) = @_;

	my $self = {};
	$self->{key}       = $key;
	$self->{keyLength} = $keyLength;

	if ($valueCount) {
		$self->{valueCount} = $valueCount;
	}
	else {
		$self->{valueCount} = 1;
		$self->{childCount} = 0;
	}

	$self->{data}      = undef;
	$self->{childZero} = undef;
	$self->{childOne}  = undef;

	bless($self);
	return $self;
}

sub incrementChildCount {
	my $self = shift;
	$self->{childCount}++;
}

sub getChildCount {
	my $self = shift;
	return $self->{childCount};
}

sub getChildZero {
	my $self = shift;
	return $self->{childZero};
}

sub setChildZero {
	my $self = shift;
	if (@_) { $self->{childZero} = shift }
}

sub getChildOne {
	my $self = shift;
	return $self->{childOne};
}

sub setChildOne {
	my $self = shift;
	if (@_) { $self->{childOne} = shift }
}

sub getKey {
	my $self = shift;
	return $self->{key};
}

sub getKeyLength {
	my $self = shift;
	return $self->{keyLength};
}

sub firstDigit {
	shift;
	my ( $key, $keyLength ) = @_;
	return ( $key >> ( $keyLength - 1 ) ) & 1;
}

sub getCommonPart {
	shift;
	my ( $keyA, $keyLengthA, $keyB, $keyLengthB ) = @_;

	# truncate the keys so they are the same size (discard low bits)
	if ( $keyLengthA > $keyLengthB ) {
		$keyA >>= $keyLengthA - $keyLengthB;
		$keyLengthA = $keyLengthB;
	}
	else {
		$keyB >>= $keyLengthB - $keyLengthA;
	}

	my $diff  = $keyA ^ $keyB;
	my $count = 0;
	while ( $diff != 0 ) {
		$diff >>= 1;
		$count++;
	}

	my $keyCommon       = $keyA >> $count;
	my $keyLengthCommon = $keyLengthA - $count;

	return ( $keyCommon, $keyLengthCommon );
}

sub Equals {
	my $self = shift;
	my ($node) = @_;

	return $node
	  && ( $self->{key} == $node->{key}
		&& $self->{keyLength} == $node->{keyLength} );
}

sub isKey {
	my $self = shift;
	return $self->{valueCount} > 0;
}

sub getValueCount {
	my $self = shift;
	return $self->{valueCount};
}

sub setValueCount {
	my $self = shift;
	my ($value) = @_;

	if ( ref($value) == 'SCALAR' ) {
		$self->{valueCount} = $value;
	}
	else {
		$self->{data} = $value;
	}
}

sub getData {
	my $self = shift;
	return $self->{data};
}

sub setData {
	my $self = shift;
	if (@_) { $self->{data} = shift }
}

sub Add {
	my $self = shift;
	my ( $key, $keyLength, $data ) = @_;

	if ( $key == $self->{key} && $keyLength == $self->{keyLength} ) {
		$self->{valueCount}++;
	}
	else {
		my $keyDiff;
		my $keyLengthDiff;
		my $newNode;

		my @commonKeyAndKeyLength =
		  TrieNode->getCommonPart( $key, $keyLength, $self->{key}, $self->{keyLength} );

		my $keyCommon       = $commonKeyAndKeyLength[0];
		my $keyLengthCommon = $commonKeyAndKeyLength[1];

		$self->{childCount}++;

		$keyLengthDiff = $self->{keyLength} - $keyLengthCommon;
		$keyDiff       = $self->{key} - ( $keyCommon << $keyLengthDiff );

		if ( $keyLengthDiff > 0 ) {
			$newNode = TrieNode->new( $keyDiff, $keyLengthDiff );
			$newNode->{valueCount} = $self->{valueCount};
			$newNode->{childZero}  = $self->{childZero};
			$newNode->{childOne}   = $self->{childOne};
			$newNode->{data}       = $self->{data};
			$newNode->{childCount} = $self->{childCount} - 1;

			# update this node to hold common part
			$self->{key}        = $keyCommon;
			$self->{keyLength}  = $keyLengthCommon;
			$self->{valueCount} = 0;
			$self->{data}       = undef;

			# and set the new node as child of this node
			if ( TrieNode->firstDigit( $keyDiff, $keyLengthDiff ) == 1 ) {
				$self->{childZero} = undef;
				$self->{childOne}  = $newNode;
			}
			else {
				$self->{childZero} = $newNode;
				$self->{childOne}  = undef;
			}

			if (!(defined $newNode->{childOne} or defined $newNode->{childZero})) {
				$self->{childCount}++;
				if ( $newNode->{childCount} > 1 ) {
					print "confusion";
				}
				$newNode->{childCount} = 0;
			}
		}    

		# process diff with the new key, if any
		if ( $keyLength > $keyLengthCommon ) {

				# get diff with the new key
			$keyLengthDiff = $keyLength - $keyLengthCommon;
			$keyDiff       = $key - ( $keyCommon << $keyLengthDiff );
			
			if ( TrieNode->firstDigit( $keyDiff, $keyLengthDiff ) == 1 ) {
				if ( defined $self->{childOne} ) {
					$self->{childOne}->Add( $keyDiff, $keyLengthDiff, $data );
				}
				else {
					$self->{childOne} =  TrieNode->new( $keyDiff, $keyLengthDiff );
					$self->{childOne}->setData($data);
				}
			}
			else {
				if ( defined $self->{childZero} ) {
					$self->{childZero}->Add( $keyDiff, $keyLengthDiff, $data );
				}
				else {
					$self->{childZero} =  TrieNode->new( $keyDiff, $keyLengthDiff );
					$self->{childZero}->setData($data);
				}
			}
		}
		else {
			$self->{valueCount} = 1;

			#$self->{data} = $data; //XXX
		}
	}
	return $self;
}

sub FindExactMatch {
	my $self = shift;
	my ( $key, $keyLength ) = @_;

	my $matchStatus;
	my $keyCommon;
	my $keyLengthCommon;

	if ( $keyLength < $self->{keyLength} ) {
		$matchStatus = 0;
		return $matchStatus;
	}
	elsif ( $key == $self->{key} && $keyLength == $self->{keyLength} ) {
		$matchStatus = 1;
		return $matchStatus;
	}
	else {
		my @keyFields = TrieNode->getCommonPart( 
			$key, $keyLength, $self->{key}, $self->{keyLength} );
		
		$keyCommon       = $keyFields[0];
		$keyLengthCommon = $keyFields[1];
		my $keyLengthDiff = $keyLength - $keyLengthCommon;
		my $keyDiff       = $key - ( $keyCommon << $keyLengthDiff );
		if ( TrieNode->firstDigit( $keyDiff, $keyLengthDiff ) == 1 ) {
			if ( defined $self->{childOne} ){
			  return $self->{childOne}->FindExactMatch( $keyDiff, $keyLengthDiff );
			}else {
				$matchStatus = 0;
				return $matchStatus;
			}
		}
		else {
			if ( defined $self->{childZero} ){
			  return $self->{childZero}->FindExactMatch( $keyDiff, $keyLengthDiff );
			}else {
				$matchStatus = 0;
				return $matchStatus;
			}
		}
	}
}

sub FindBestMatch {
	my $self = shift;
	my ( $key, $keyLength ) = @_;

# note : we don't need to worry about a node being a terminator since at the end, we will either have
# - an exact match of the key, so the node will be a terminator
# - the last possible node on the path matching the key which can't be anything but a leaf, hence a terminator

	if ( $keyLength < $self->{keyLength}
		|| ( $key == $self->{key} && $keyLength == $self->{keyLength} ) ){
		
		return $self;
	}
	else {
		my @keyFields = TrieNode->getCommonPart( 
				$key, $keyLength, $self->{key}, $self->{keyLength} );
		
		my $keyCommon       = $keyFields[0];
		my $keyLengthCommon = $keyFields[1];

		my $keyLengthDiff = $keyLength - $keyLengthCommon;
		my $keyDiff       = $key - ( $keyCommon << $keyLengthDiff );

		if ( TrieNode->firstDigit( $keyDiff, $keyLengthDiff ) == 1 ) {
			if ( defined $self->{childOne} ) {
				return $self->{childOne}->FindBestMatch( $keyDiff, $keyLengthDiff );
			}
			else {
				return $self;
			}
		}
		else {
			if ( defined $self->{childZero} ) {
				return $self->{childZero}->FindBestMatch( $keyDiff, $keyLengthDiff );
			}
			else {
				return $self;
			}
		}
	}
}

sub Clone {
	my $self = shift;
	
	my $clone = TrieNode->new( $self->{key}, $self->{keyLength}, $self->{valueCount} );
	if ( defined $self->{childZero} ) {
		$clone->{childZero} = $self->{childZero}->Clone();
	}
	if ( defined $self->{childOne} ) {
		$clone->{childOne} = $self->{childOne}->Clone();
	}

	return $clone;
}


=cut

Not used?

sub printDotNode(TrieNode node, long position, long currentKey) {
    	TrieNode c0 = node.getChildZero();
    	TrieNode c1 = node.getChildOne();
    	long key = node.getKey();
    	long mask = Constants.MAX_KEY_LENGTH - position;
    	String keyString;
    	String addrString;
    	
    	if (key == -1) {
    		addrString = keyString = "\"" + "0.0.0.0/0" + "\"";
    		currentKey = 0;
    		p.println(addrString + " [shape=record,label=\"<f0>0.0.0.0/0|<f1>" 
    				+ node.getChildCount()
    				+ "\"];" + " // COUNT: " + node.getChildCount());
    	}
    	else {
    		key = currentKey;
    		keyString = helper.longToIP(key);
    		String unquotedAddrString = keyString + "/" + mask;
    		addrString = "\"" + keyString + "/" + mask + "\"";
    		if (node.getData() == null) {
    			//p.println(addrString + " [style=filled];" + " // COUNT: " + node.getChildCount());
    			p.println(addrString + " [style=filled,shape=record,label=\"<f0>" + unquotedAddrString
    					+ "|<f1>" + node.getChildCount() + "\"]"
    					+ "; // COUNT: " + node.getChildCount());
    		}
    		else {
    			//p.println(addrString + "; // COUNT: " + node.getChildCount());
    			p.println(addrString + " [shape=record,label=\"<f0>" + unquotedAddrString
    					+ "|<f1>" + node.getChildCount() + "\"]"
    					+ "; // COUNT: " + node.getChildCount());
    		}
    	}
    	
    	if (c0 != null) {
    		long c0Key = c0.getKey() << (position - c0.getKeyLength());
    		long c0Position = position - c0.getKeyLength();
    		long c0Mask = Constants.MAX_KEY_LENGTH - c0Position;
    		c0Key = c0Key | currentKey;
    		p.println(addrString + " -> \"" 
    				+ helper.longToIP(c0Key) + "/" + c0Mask
    				+ "\"" + "[label=" + (c0Mask - mask)  
    				+ "];" + "// kl: " + c0.getKeyLength() + " pos: " + position);
    		printDotNode(p, c0, c0Position, c0Key);	
    	}
    	if (c1 != null) {
    		long c1Key = c1.getKey() << (position - c1.getKeyLength());
    		long c1Position = position - c1.getKeyLength();
    		long c1Mask = Constants.MAX_KEY_LENGTH - c1Position;
    		c1Key = c1Key | currentKey;
    		p.println(addrString + " -> \"" 
    				+ helper.longToIP(c1Key) + "/" + c1Mask
    				+ "\"" + "[label=" + (c1Mask - mask)
    				+ "];"  + "// kl: " + c1.getKeyLength() + " pos: " + position);
    		printDotNode(p, c1, c1Position, c1Key);
    	}
    }
    
    public ArrayList<String> listInternalNodes(ArrayList<String> listOfNodes, long position, long currentKey) {
    	TrieNode c0 = $self->{getChildZero();
    	TrieNode c1 = $self->{getChildOne();
    	long key = $self->{getKey();
    	long mask = Constants.MAX_KEY_LENGTH - position;
    	String keyString;
    	String addrString;
    	TrieNode node = this;
    	
    	if (key == -1) {
    		addrString = keyString = "0.0.0.0/0";
    		currentKey = 0;
    	}
    	else {
    		key = currentKey;
    		keyString = helper.longToIP(key);
    		addrString = keyString + "/" + mask;
    		if (node.getData() == null) {
    			listOfNodes.add(addrString);
    		}
    	}
    	if (c0 != null) {
    		long c0Key = c0.getKey() << (position - c0.getKeyLength());
    		long c0Position = position - c0.getKeyLength();
    		//long c0Mask = Constants.MAX_KEY_LENGTH - c0Position;
    		c0Key = c0Key | currentKey;
    		c0.listInternalNodes(listOfNodes, c0Position, c0Key);
    	}
    	if (c1 != null) {
    		long c1Key = c1.getKey() << (position - c1.getKeyLength());
    		long c1Position = position - c1.getKeyLength();
    		//long c1Mask = Constants.MAX_KEY_LENGTH - c1Position;
    		c1Key = c1Key | currentKey;
    		c1.listInternalNodes(listOfNodes, c1Position, c1Key);
    	}

    	return listOfNodes;
    }
    
    /**
     * 
     * This method returns all the nodes which are necessary to summarize all inputs.
     * 
     * @param listOfNodes
     * @param position
     * @param currentKey
     * @return
     */
    public ArrayList<String> listSummaryNodes(ArrayList<String> listOfNodes, long position, long currentKey) {
    	TrieNode c0 = $self->{getChildZero();
    	TrieNode c1 = $self->{getChildOne();
    	long key = $self->{getKey();
    	long mask = Constants.MAX_KEY_LENGTH - position;
    	String keyString;
    	String addrString;
    	TrieNode node = this;
    	
    	if (key == -1) {
    		addrString = keyString = "0.0.0.0/0";
    		currentKey = 0;
    	}
    	else {
    		key = currentKey;
    		keyString = helper.longToIP(key);
    		addrString = keyString + "/" + mask;
    		if (node.getData() == null &&
    				 ( c0.getData() != null ||
    				c1.getData() != null )) {
    			listOfNodes.add(addrString);
    		}
    	}
    	if (c0 != null) {
    		long c0Key = c0.getKey() << (position - c0.getKeyLength());
    		long c0Position = position - c0.getKeyLength();
    		//long c0Mask = Constants.MAX_KEY_LENGTH - c0Position;
    		c0Key = c0Key | currentKey;
    		c0.listSummaryNodes(listOfNodes, c0Position, c0Key);
    	}
    	if (c1 != null) {
    		long c1Key = c1.getKey() << (position - c1.getKeyLength());
    		long c1Position = position - c1.getKeyLength();
    		//long c1Mask = Constants.MAX_KEY_LENGTH - c1Position;
    		c1Key = c1Key | currentKey;
    		c1.listSummaryNodes(listOfNodes, c1Position, c1Key);
    	}

    	return listOfNodes;
    }
}

=cut

1;
}}}

==== Test Script test.pl ====

This script tests the proposed implementation.  It should be executed as:

    `perl test.pl inputIPfile`

where _inputIPfile_ is a text file containing some IP numbers for which the summarization is to be calculated.  The script outputs two files:

    `inputIPfile_`-summary.txt_     and
    `inputIPfile_`-summary.dot_

where the _txt_ file contains the summarizing nodes, and the _dot_ file contains an input file to be used with [http://www.graphviz.org/ Graphviz] tool.

== Project Management ==

Most details TBD, basic outline:


|| _*Dates*_ || _*Task*_ || _*People*_ ||
|| Weekly || Conference Call - Discuss progress || Jason, Martin, Student (Jeff) || 
|| March 9th - 13th || Evaluate, Learn Current Alg - Identify Failure Points || Student (Martin, Jason) || 
|| March 16th - 20th || Propose Changes (in writing), Experiment on Hypothesis (in code), Publish Results (in writing) || Student (Martin, Jason) || 
|| March 23rd - 27th || Finalize Code in prototype, integration into gLS || Student, Jason (Martin) || 
|| March 30th - April 10th || Planet Lab Beta Testing - Construct Testbed? || Student, Brian T, Jason (Jeff, Martin) || 
|| Late April || Slack time, Member Meeting, Beta Release of New Code || All || 


=== Actions ===

 * JZ 
   * Gather Datasets
   * Assist student in any and all tasks
   * gLS Integration
   * Final report on tasks
 * MS
   * Supervise student
   * weekly reports
   * Assist in researching proper algorithms
   * review progress of performance/effectiveness
 * Student
   * Review existing design of algorithm and source code
   * Propose changes to algorithm
   * Implement changes (several prototypes) in source code
   * Experimentation on data sets
   * Evaluation of results (correctness, speed, effectiveness)
   * Final source code review
   * Assist Jason in gLS integration
   * Assist Brian/Jason in test framework design, installation, testing
   * Final report on tasks
 * BT
   * Review current gLS design (April timeframe) 
   * Assist student in designing test framework
   * Assist student in framework deployment
   * review progress of performance/effectiveness
 * AB
   * Review current gLS design (April timeframe) 
   * Think about impact of topology in summarization
 * JB
   * review progress of performance/effectiveness
   * Review current gLS design (April timeframe) 
 * All
   * Review new algorithm (both effectiveness and performance) before gLS integration
 == Last Modified ==
$Id$ 