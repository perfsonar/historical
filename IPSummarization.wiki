#summary IP Summarization Algorithm in Perl

<wiki:toc max_depth="6" />

== Introduction ==

The effective and efficient summarization of the IPv4 (and eventually IPv6) address space is paramount for the Information services of perfSONAR.  The current algorithm has been the mainstay since advent of the gLS, and may take liberties with the final output:

 * Summarization is not as _tight_ as possible.  For instance given several addresses that share an A class subnet (e.g. 192.168.0.56, 192.168.48.98, 192.168.48.197) a larger than required CIDR recommendation is made: 192.0.0.0/8.  
 * Multiple ranges may confuse the overall output.  If two primary ranges are seen, 192.168.0.0/16 and 10.10.0.0/16, the recommendation may be returned that is even greater, e.g. 0.0.0.0/0.

Implementations should also consider:

 * Efficiency for input size
 * Internal data structures, such as IPTrie.  
 
The following document describes the current state of the algorithm and then lays out recommendations for upgrade as well as a work plan.  Schedules are not exact.

== Current ==

The current algorithm was developed by Jason and Martin in the Spring/Summer of 2008.  This culminated in the release of the perfSONAR-PS gLS for June of 2008.  

=== Current Algorithm ===

This algorithm makes heavy use of the concept of an IPTrie data structure.  A basic description follows:

 # Read in complete list of IP addresses.  For a given hLS the pattern should be similar to:
   * Many distinct addresses in a certain range (e.g. an SNMP MA is deployed in a single domain).
   * Potentially several ranges (if the hLS is shared)
   * _Outliers_, this is seen for point to point services such as _PingER_ and _perfSONAR-BUOY_
 # Given our list of IP addresses we need to groom the data.
   * CIDR Summarization (using [http://search.cpan.org/dist/Net-CIDR/CIDR.pm Net::CIDR]).  We really want to get _*all*_ CIDR summaries for any IP Address (simply put, what _range_ is a given IP address valid in). An Example using _*128.4.133.164*_.  A complete list of CIDR descriptions follows:
{{{
       128.4.133.164/32
       128.4.133.164/31
       128.4.133.164/30
       128.4.133.160/29
       128.4.133.160/28
       128.4.133.160/27
       128.4.133.128/26
       128.4.133.128/25
       128.4.133.0/24
       128.4.132.0/23
       128.4.132.0/22
       128.4.128.0/21
       128.4.128.0/20
       128.4.128.0/19
       128.4.128.0/18
       128.4.128.0/17
       128.4.0.0/16
       128.4.0.0/15
       128.4.0.0/14
       128.0.0.0/13
       128.0.0.0/12
       128.0.0.0/11
       128.0.0.0/10
       128.0.0.0/9
       128.0.0.0/8
       128.0.0.0/7
       128.0.0.0/6
       128.0.0.0/5
       128.0.0.0/4
       128.0.0.0/3
       128.0.0.0/2
       128.0.0.0/1
       0.0.0.0/0
}}}
   * The next step involves looking at these numbers for _all_ IP addresses that we started with.  For lack of a better term I refer to this as _*voting*_.  We keep a running tally of how many of the starting addresses share the common ancestors of CIDR descriptions.  An example using _*128.4.40.17*_ and _*128.4.133.164*_.  These addresses share the following CIDR ranges, with the _tightest_ being at the top.
{{{
       128.4.0.0/16
       128.4.0.0/15
       128.4.0.0/14
       128.0.0.0/13
       128.0.0.0/12
       128.0.0.0/11
       128.0.0.0/10
       128.0.0.0/9
       128.0.0.0/8
       128.0.0.0/7
       128.0.0.0/6
       128.0.0.0/5
       128.0.0.0/4
       128.0.0.0/3
       128.0.0.0/2
       128.0.0.0/1
       0.0.0.0/0
}}}
 # Next we need to make the IPTrie (e.g. Patricia Trie - we use the [http://search.cpan.org/~cvicente/Net-IPTrie-v0.4/lib/Net/IPTrie.pm Net::IPTrie] module).  Making the Trie consists of:
   # Insert all of the original addresses into the Trie with a /32 prefix.  This does not need to be done in order.
   # Insert all of the _voted_ and shared CIDR ranges _*in order, from most to least*_.  The ordering matters here for Trie construction.
 # After we have our Trie we have the option of _pruning_ it to remove dead ends
 # Finally we do a walk of the Trie to print out (for Graphical Purposes) and to establish:
   # _*Maximum Dominator*_ - Find the _tightest_ CIDR range for all inputs
   # _*K Dominators*_ - Walk _down the tree_, towards the leaves, and find the _K_ dominators that still describe all leaves in the _tightest_ possible manner.
 
=== Example ===

Consider this input set of data, representative of some service:

{{{
    128.175.13.92
    128.175.13.74
    128.4.40.10
    128.4.40.12
    128.4.40.17
    128.4.131.23
    128.4.133.167
    128.4.133.163
    128.4.133.164
}}}

When all is said and done, we are left with the following Trie (when using the above algorithm:

http://perfsonar-ps.googlecode.com/svn/wiki/IPSummarization/graph.png

The top CIDR, _*128.0.0.0/8*_, dominates all leaves and is as _tight_ as possible.   To select the _K_ dominators we can craft an arbitrary rule to _slice_ off portions of the tree that directly touch a leaf:

http://perfsonar-ps.googlecode.com/svn/wiki/IPSummarization/graph2.png

This allows us to choose 3 dominators:
{{{
    128.175.13.64/27
    128.4.128.0/21
    128.4.40.0/27
}}}

=== Current Implementation ===

The following is a short script that implements the above algorithm.  It is written in perl and currently present in all production gLS instances.  Comments are inserted where obvious changes to the algorithm were made.  Important deviations:

 # The IPTrie object is not sound.  Modifications to the Trie are required after construction to properly link the pointers of children and parents.  For this reason we may wish to implement our own IPTrie.  It remains because it does offer some useful functions (e.g. printing out the Trie)
 # Voting is rather simple.  We simply rank by shared parent
 # Graphviz notation provided to make pretty pictures.

{{{
#!/usr/bin/perl -w

use strict;
use warnings;

=head1 NAME

ipTree.pl - Utility to demonstrate the effectivness of CIDR summarizations of
IP addresses as well as a potential solution to finding dominating values
when used in a Radix Tree (Patricia Trie) data structure.

=head1 USAGE

  perl ipTree.pl

An outputed list of the minimum dominators of the resulting IPTrie will be
be displayed.  This will generate a graphviz .dot file (graph.dot) of the
IPTrie that can then be used with the graphviz executable:

  dot graph.dot -Tpng -o graph.png

=head1 DESCRIPTION

The perfSONAR dLS and gLS require a way to summarize large amounts of
topological data (namely IP addresses of type IPv4 and IPv6).  Using the
well known CIDR way of specificying IP address ranges, this simple script aims
to combine the 'dominating' (i.e. greatest available CIDR summaries) for some
set of source IP addresses.

The output is placed into a graphviz dot file for display.

=cut

use Net::CIDR ':all';
use Net::IPTrie;
use Data::Dumper;

# IP Trie Data Structure (similar to Net::Patricia)
my $tr = Net::IPTrie->new( version => 4 );

# I need to be able to do my own manipulations (e.g. IPTrie is not really
# that great...)
my %tree = ();

# Ensure that each child only has one parent (IPTrie data structure
# uses a strange internal representation).
my %claim = ();

# starting list of IPs

my @map = ( "128.175.13.92", "128.175.13.74", "128.4.40.10", "128.4.40.12", "128.4.40.17", "128.4.131.23", "128.4.133.167", "128.4.133.163", "128.4.133.164" );

#my @map = ("150.254.160.194",
#           "150.254.160.195",
#           "150.254.160.196",
#           "120.10.0.11",
#           "120.10.0.12",
#           "120.10.0.17",
#           "120.11.5.1",
#           "120.11.5.2",
#           "80.15.11.2",
#           "80.15.11.3");

#my @map = ("64.57.25.15",
#           "64.57.27.4",
#           "64.57.27.138",
#           "128.4.12.12",
#           "128.4.13.1",
#           "160.135.1.1",
#           "207.75.165.151",
#           "207.72.226.18",
#           "206.72.224.1");

my $vote = getCDIRSummaries( \@map );
$tr = makePatriciaTrie( \@map, $vote, $tr );
manipulatePatriciaTrie( \@map, $tr );
genGraph( \%tree );
listMinDoms();

exit( 1 );

=head2 getCDIRSummaries($map)

Given a list of IP addresses, gather the CIDR representations then 
group this by a popularity ranking (i.e. if there are 9 hosts, and 9
have a set grouping of CIDR values in common, this is a dominator).

=cut

sub getCDIRSummaries {
    my ( $map ) = @_;

    my %tally = ();
    foreach my $host ( @{$map} ) {
        my @list = Net::CIDR::addr2cidr( $host );
        foreach my $range ( @list ) {

            # we want to ingore the wildcard addresses...
            next if $range =~ m/^0\./;

            $tally{$range}++ if defined $tally{$range};
            $tally{$range} = 1 if not defined $tally{$range};
        }
    }

    return \%tally;
}

=head2 makePatriciaTrie($map, $votes, $tr)

Creates the initial IPTrie structure using the list of 
available hosts (e.g. $map) and the CIDR values for
each (ranked into popularity groups).  The end result is
the IPTrie.

=cut

sub makePatriciaTrie {
    my ( $map, $tally, $tr ) = @_;

    # Start to make the IPTrie data structure.  First we add in all
    # of the 'base' addresses

    foreach my $host ( @{$map} ) {
        $tr->add( address => $host, prefix => "32" );
    }

    # Now we add in the summaries.

    foreach my $t ( sort keys %{$tally} ) {
        my @parts = split( /\//, $t );
        $tr->add( address => $parts[0], prefix => $parts[1] );
    }

    return $tr;
}

=head2 extract($parent, $node, $status, $side)

This aux function recursively walks the nodes of the IPTrie structure
and creates a more usefriendly tree that we will use for manipulation
and final display.

=cut

sub extract {
    my ( $parent, $node, $status, $side ) = @_;
    my $me = "";
    $me = $node->[3] . "/" . $node->[5] if defined $node->[3] and defined $node->[5];
    if ( $me and $side and ( not $claim{$me} ) ) {
        push @{ $tree{$parent}{"C"} }, $me;
        $claim{$me} = 1;
    }
    $status = extract( $parent, $node->[1], $status, "L" ) if $node->[1] and ( not $status->{"L"} );
    $status = extract( $parent, $node->[2], $status, "R" ) if $node->[2] and ( not $status->{"R"} );
    return $status;
}

=head2 manipulatePatriciaTrie($tr)

Given the IPTrie structure, we need to manually manipulate the nodes into
our own format.

=cut

sub manipulatePatriciaTrie {
    my ( $map, $tr ) = @_;

    my $list  = ();
    my $code  = sub { push @$list, shift @_; };
    my $count = $tr->traverse( code => $code );

    # hacky root pointer (gives us unification if the whild card [0.*]
    # was really needed)

    my @temp = ();
    $tree{"Root"}{"C"} = \@temp;
    $tree{"Root"}{"U"} = "NULL";

    # we need to go backwards when looking at the IPTrie print out, this is
    # is really to be sure children aren't all claimed by the root (the internal
    # structure is a little strange) so this ensures we hit the root last.

    foreach my $node ( reverse @{$list} ) {
        my $me = "";
        $me = $node->[3] . "/" . $node->[5] if defined $node->[3] and defined $node->[5];
        next unless $me;

        # each one of our node-keys has some location information
        my @temp = ();
        $tree{$me}{"C"} = \@temp;
        $tree{$me}{"U"} = "";

        # recursively search the tree, stop after you find a left and right
        # child though (N.B. this creates problems unfortunately, so we need
        # to manually manipulate...)
        my %status = (
            "L" => 0,
            "R" => 0
        );
        extract( $me, $node, \%status, "" );
    }

    # link all the parent information for each node and child

    foreach my $item ( keys %tree ) {
        foreach my $c ( @{ $tree{$item}{"C"} } ) {
            $tree{$c}{"U"} = $item if $c and $item;
        }
    }

    # First step: Start at the leaves and walk toward the root.
    # - Every time we see a node with a sinle child, collapse it into the parent
    #   (we are pruning the tree)

    foreach my $host ( @{$map} ) {
        my $current = $host . "/32";
        while ( $current ) {
            my $delete = "";
            if (    $#{ $tree{ $tree{$current}{"U"} }{"C"} } == 0
                and not( $current =~ m/\/32$/ )
                and $#{ $tree{$current}{"C"} } == 0 )
            {
                $delete = $current;
                foreach my $child ( @{ $tree{$current}{"C"} } ) {
                    $tree{$child}{"U"} = $tree{$current}{"U"};
                }
                $tree{ $tree{$current}{"U"} }{"C"} = $tree{$current}{"C"};
                delete $tree{$delete}{"C"};
            }
            $current = $tree{$current}{"U"};
            delete $tree{$delete} if $delete;
        }
    }

    # Second step: Start at the leaves and walk toward the root.
    # - Every time we see a single child node, collapse it into the child (this
    #   is the opposite of what we just did, but this handles branching much
    #   better, this is also a form of pruning).

    foreach my $host ( @{$map} ) {
        my $current = $host . "/32";
        while ( $current ) {
            my $delete = "";
            if ( $#{ $tree{$current}{"C"} } == 0 ) {
                $delete = $current;
                foreach my $child ( @{ $tree{$delete}{"C"} } ) {
                    $tree{$child}{"U"} = $tree{$delete}{"U"};
                    push @{ $tree{ $tree{$delete}{"U"} }{"C"} }, $child;
                }

                my $counter = 0;
                foreach my $child ( @{ $tree{ $tree{$delete}{"U"} }{"C"} } ) {
                    if ( $child eq $current ) {
                        my $remove = splice( @{ $tree{ $tree{$delete}{"U"} }{"C"} }, $counter, 1 );
                    }
                    $counter++;
                }
            }
            $current = $tree{$current}{"U"};
            delete $tree{$delete} if $delete;
        }
    }

    # finally link the tree(s) to the root pointer

    foreach my $node ( keys %tree ) {
        unless ( $tree{$node}{"U"} ) {
            $tree{$node}{"U"} = "Root";
            push @{ $tree{"Root"}{"C"} }, $node;
        }
    }

    return;
}

=head2 genGraph

Outputs the contents of the tree structure into a "Graphviz" formated
DAG file.  

=cut

sub genGraph {

    open( DOT, ">graph.dot" );
    print DOT "digraph g {\n";

    foreach my $item ( keys %tree ) {
        next unless $item;
        if ( $item =~ m/\/\d+$/ ) {
            my @array = ();
            @array = split( /\//, $item );

            # color the terminal elements so we know they are not dominators
            if ( $array[1] eq "32" ) {
                print DOT "\t\"", $item, "\"[ color=crimson, style=filled ];\n";
            }
            else {
                print DOT "\t\"", $item, "\";\n";
            }
        }
        else {

            # this is the root...

            print DOT "\t\"", $item, "\"[ color=yellow, style=filled ];\n";
        }
    }

    # output the linkings

    foreach my $item ( keys %tree ) {
        next unless $item;
        foreach my $c ( @{ $tree{$item}{"C"} } ) {
            next unless $c;
            print DOT "\t\"", $item, "\" -> \"", $c, "\";\n";
        }
    }

    print DOT "}\n";
    close( DOT );
    return;
}

=head2 listMinDoms

Given the tree, 'slice off' the top level of nodes that are
not necessarily representative of the domination (e.g. if they
are just used to direct traffic through the tree, and do not
have direct /32 children).  We return a list of nodes that
represent the minimum set of addresses that can be used to
describe any of the originals.

=cut

sub listMinDoms {

    # First locate the root in the tree

    my @expand = ();
    foreach my $node ( sort keys %tree ) {
        if ( $node and $tree{$node}{"U"} eq "Root" ) {

            # add the root the 'expand' list so we can
            # examine it (and it's children, etc.) then
            # exit
            push @expand, $node;
        }
    }

    my $counter = 0;
    my @minDoms = ();

    # now we are going to walk the tree.  If a non-leaf
    # node has two non-leaf children is is useless to us,
    # so we skip it.  If a non-leaf node has at least one
    # leaf child, this is a part of our 'boundary' so
    # we list it as a minDominator.

    while ( $expand[$counter] ) {
        my $minDomFlag = 0;
        my $expandFlag = 0;

        foreach my $child ( sort @{ $tree{ $expand[$counter] }{"C"} } ) {
            my @array = split( /\//, $child );

            # /32's are leaf nodes, if one of our children is a leaf
            # we are a on the min dominator boundary
            if ( $array[1] eq "32" ) {

                # Make sure we only add the node once...
                if ( ( $#minDoms == -1 ) or ( $minDoms[$#minDoms] ne $expand[$counter] ) ) {
                    push @minDoms, $expand[$counter];
                }
                $minDomFlag++;
            }
            else {

                # If we have a non leaf node as a child, we will probably
                # need to expland that child later...

                push @expand, $child;
                $expandFlag++;
            }
        }

        # corner case: if we have a non leaf child and a leaf
        # child we need to remove the non leaf child from the
        # expand list

        pop @expand if $expandFlag and $minDomFlag;
        $counter++;
    }

    print "Min Dominators:\n\n";
    foreach my $f ( @minDoms ) {
        print $f , "\n";
    }

    return;
}

__END__

=head1 SEE ALSO

L<Net::CIDR>, L<Net::IPTrie>

To join the 'perfSONAR-PS' mailing list, please visit:

  https://mail.internet2.edu/wws/info/i2-perfsonar

The perfSONAR-PS subversion repository is located at:

  https://svn.internet2.edu/svn/perfSONAR-PS

Questions and comments can be directed to the author, or the mailing list.
Bugs, feature requests, and improvements can be directed here:

  https://bugs.internet2.edu/jira/browse/PSPS

=head1 VERSION

$Id$

=head1 AUTHOR

Jason Zurawski, zurawski@internet2.edu

=head1 LICENSE

You should have received a copy of the Internet2 Intellectual Property Framework
along with this software.  If not, see
<http://www.internet2.edu/membership/ip.html>

=head1 COPYRIGHT

Copyright (c) 2008-2009, Internet2

All rights reserved.

=cut
}}}

=== Criticisms (From the Author and Others) ===

 # _K_ dominator selection is arbitrary
   * Yes, my initial decision was based on _*this looks correct*_ instead of some heuristic.
   * It would be nice to define such a heuristic
   * Need to consider the _weight_ of leaves under a given CIDR node, this can effect if we choose it
 # Trie construction only considers _shared_ CIDR ranges
   * I think this is mostly correct, but we may want to consider the _weight_ (see above) and how it effects other nodes in the tree.
 # Pruning the trie is not _destructive_
   * Implement something that allows pruning to remove some ranges and replace it with other, possibly tighter and unrelated ranges.

== Proposal ==

The proposed changes should address the overall algorithm (evaluate for correctness and completeness - compete with other attempts).  Once an suitable algorithm is found in experimentation and verified in testing, the final result will be installed into gLS and tested in a distributed environment (e.g. [https://www.planet-lab.org/ PlanetLab]).  

This work should be done primarily by the student, with help from:

 * Jason - Current Algorithm/Perl/gLS
 * Martin - Current Algorithm/Research Aspects
 * Brian T - Testing
 * Jeff - Current Algorithm/Resources
 * Aaron - Topology Considerations

=== Proposed Data Sets ===

The following data sets were gathered from perfSONAR services in March 2009.

==== APAN ====

{{{
203.181.248.150
202.180.34.158
203.181.248.225
203.181.102.130
45.0.0.1
203.178.133.141
203.181.248.242
203.181.249.19
172.24.100.210
203.181.248.154
203.181.249.118
192.203.116.146
203.181.249.25
203.181.248.66
203.181.194.158
203.181.249.100
203.181.194.246
203.181.248.47
203.181.249.117
203.181.248.117
203.181.248.251
203.181.248.110
203.181.248.109
203.181.248.228
203.181.248.185
203.181.249.17
202.178.96.85
133.69.37.1
203.181.248.133
203.181.195.62
203.181.249.11
203.181.194.82
203.181.249.82
203.181.248.102
203.181.194.125
203.181.249.97
203.181.248.62
203.181.249.94
203.181.248.168
203.181.248.101
203.181.249.237
203.181.195.161
203.181.248.115
203.181.248.166
203.181.249.78
203.181.248.170
202.180.34.134
203.181.194.126
203.181.248.238
202.40.161.239
117.103.111.133
203.181.249.90
203.181.248.204
203.181.248.49
203.181.248.250
203.181.248.182
203.181.248.190
203.181.248.209
203.181.249.24
203.181.249.73
202.249.2.160
203.181.194.89
203.181.248.134
203.181.248.81
203.181.249.158
203.181.249.193
203.181.248.69
203.181.248.162
203.181.249.218
203.181.249.129
203.181.195.30
203.181.248.229
203.181.249.238
203.181.248.243
203.181.249.86
203.181.249.137
203.181.249.253
203.181.249.101
203.181.249.105
203.181.249.70
192.203.116.150
163.220.127.238
203.181.248.158
203.181.249.213
10.0.0.4
203.181.248.178
203.181.248.142
203.181.249.177
172.24.61.30
203.181.248.138
203.181.195.193
203.181.249.122
140.221.251.2
203.181.248.147
203.181.194.225
203.181.249.102
192.203.116.154
203.181.248.218
203.181.248.144
203.181.194.254
203.181.249.126
202.179.241.37
203.181.194.198
203.181.248.97
}}}

==== ESnet ====

{{{
198.129.248.121
134.55.217.89
134.55.219.9
134.55.209.41
134.55.218.5
134.55.213.205
134.55.213.74
198.124.194.9
134.55.42.10
134.55.208.126
198.124.216.157
134.55.217.82
134.55.42.18
198.124.238.1
134.55.217.6
134.55.200.74
192.168.201.5
192.107.175.3
134.55.222.62
134.55.221.42
134.55.218.70
134.55.217.113
134.55.8.130
134.55.200.65
134.55.8.162
134.55.209.174
134.55.200.37
198.129.78.113
198.129.248.133
192.245.178.6
134.55.221.33
134.55.209.98
192.84.8.50
134.55.209.218
134.55.218.89
134.55.209.173
134.55.217.81
134.55.219.18
134.55.217.1
134.55.213.210
134.55.220.50
134.55.11.225
198.125.140.97
134.55.213.93
134.55.220.53
134.55.213.85
134.55.200.66
192.33.240.193
134.55.217.17
134.55.219.33
134.55.210.217
134.55.219.86
134.55.218.21
62.40.125.78
134.55.200.15
134.55.218.10
134.55.43.2
134.55.213.217
198.124.216.133
134.55.213.245
134.55.219.38
134.55.218.110
134.55.207.21
198.129.77.5
134.55.217.38
134.55.209.38
134.55.211.14
134.55.222.45
198.129.254.5
134.55.209.85
198.124.194.5
134.55.211.97
198.124.216.137
134.55.209.42
134.55.212.51
134.55.220.25
134.55.209.73
198.124.252.125
134.55.218.42
134.55.213.233
134.55.209.21
198.124.252.102
192.31.96.2
198.129.248.105
134.55.219.10
198.124.216.197
134.55.217.110
134.55.221.13
150.99.198.218
134.55.222.17
134.55.200.79
172.16.32.2
137.164.27.93
134.55.217.5
134.55.213.121
192.5.170.78
134.55.213.221
134.55.207.22
134.55.219.21
134.55.218.98
192.13.56.41
198.124.208.65
134.55.200.38
198.124.224.5
134.55.200.28
134.55.217.57
207.231.241.13
198.124.17.9
134.55.209.65
134.55.200.25
134.55.16.193
211.79.48.173
134.55.200.1
62.40.125.74
198.129.252.142
134.55.219.49
198.125.140.177
134.55.219.85
198.129.76.25
198.125.140.113
134.55.12.100
198.124.252.25
134.55.210.39
134.55.217.21
134.55.212.105
134.55.10.97
134.55.221.14
18.201.0.118
134.55.221.29
198.124.238.33
134.55.219.66
134.55.222.54
207.231.248.130
134.55.217.97
134.55.213.49
134.55.208.205
198.129.77.17
134.55.220.1
134.55.217.106
134.55.200.46
134.55.210.25
198.124.216.149
134.55.200.68
134.55.217.2
134.55.210.222
198.49.208.17
198.129.33.22
134.55.211.1
134.55.200.61
128.115.190.1
198.129.79.17
134.55.6.137
134.55.218.109
134.55.207.14
198.125.140.201
198.124.134.1
198.124.238.13
192.168.201.9
134.55.200.40
134.55.213.81
134.55.209.22
134.55.210.241
134.55.34.97
134.55.207.34
134.55.211.81
198.125.140.13
192.150.29.210
134.55.219.26
134.55.219.77
117.103.111.157
134.55.218.61
207.231.249.2
134.55.212.97
134.55.209.93
134.55.212.33
134.55.213.90
198.125.140.169
207.231.247.2
198.124.216.185
134.55.217.33
134.55.200.72
134.55.221.17
134.55.209.33
134.55.217.101
198.125.140.89
198.124.254.222
198.32.153.13
192.68.191.146
134.55.218.29
134.55.216.1
134.55.218.82
134.55.29.97
207.231.248.13
134.55.38.1
134.55.215.1
134.55.218.93
134.55.211.23
134.55.218.97
198.124.232.254
198.129.76.81
134.55.211.132
134.55.207.13
134.55.217.26
134.55.200.26
198.125.140.205
134.55.218.13
134.55.213.113
199.109.4.150
134.55.211.156
134.55.213.177
134.55.19.133
134.55.220.41
134.55.219.53
134.55.213.226
134.55.219.58
134.55.212.81
134.55.200.48
134.55.200.36
134.55.18.165
134.55.207.37
134.55.200.17
134.55.10.225
134.55.21.129
198.124.216.193
134.55.213.214
134.55.209.46
198.129.33.21
134.55.33.161
134.55.218.38
134.55.200.67
198.125.140.93
134.55.12.225
134.55.213.170
198.124.200.254
134.55.213.66
192.31.99.138
134.55.213.145
134.55.213.161
198.124.252.89
198.124.16.1
134.55.218.81
134.55.16.97
134.55.219.13
134.55.221.6
134.55.213.77
134.55.217.18
134.55.209.242
134.55.222.66
134.55.221.38
134.55.217.46
134.55.200.62
207.231.246.2
192.65.95.2
134.55.213.178
134.55.200.34
134.55.38.2
134.55.217.34
134.55.18.101
134.55.42.17
134.55.20.229
134.55.22.193
198.124.228.6
134.55.213.225
134.55.211.161
134.55.217.50
134.55.209.94
134.55.13.2
134.55.217.10
134.55.210.225
134.55.200.71
134.55.218.94
198.125.140.173
192.12.208.1
134.55.219.90
198.124.252.138
134.55.213.193
134.55.219.93
198.128.15.101
134.55.211.163
134.55.214.26
134.55.212.1
134.55.217.109
198.124.192.98
207.231.245.130
207.231.242.13
134.55.213.78
198.124.252.118
198.129.254.21
198.129.254.1
192.73.7.193
198.125.140.226
198.206.221.254
134.55.209.53
134.55.211.17
134.55.11.226
198.124.238.17
134.55.200.77
134.55.209.106
134.55.219.78
134.55.218.62
134.55.218.57
134.55.213.106
134.55.213.213
134.55.209.222
134.55.209.37
134.55.219.37
134.55.200.49
134.55.218.37
198.124.216.125
134.55.200.69
134.55.20.195
134.55.213.89
134.55.200.24
134.55.220.21
198.129.254.9
134.55.211.113
134.55.200.7
198.129.33.36
134.55.213.109
134.55.213.169
134.55.221.18
134.55.200.20
134.55.219.113
134.55.220.26
134.55.218.85
134.55.23.33
134.55.220.2
134.55.218.46
134.55.42.9
134.55.217.42
134.55.219.81
134.55.219.14
134.55.221.37
147.155.254.1
134.55.211.65
128.115.190.101
134.55.219.110
198.129.33.5
134.55.13.12
134.167.160.49
134.55.210.26
207.231.240.13
134.55.213.50
134.55.217.90
150.99.199.62
134.55.222.41
198.124.238.5
134.55.29.33
134.55.212.25
192.13.56.93
134.55.210.129
134.55.200.60
134.55.209.217
134.55.214.18
134.55.213.122
134.55.218.69
198.124.17.17
134.55.218.78
134.55.209.221
134.55.214.9
198.129.76.65
134.55.213.237
134.55.209.81
134.55.213.249
198.129.78.33
134.55.213.97
198.124.216.89
134.55.207.33
134.55.221.1
134.55.213.149
134.55.213.114
134.55.219.65
134.55.217.114
134.55.212.41
198.124.216.145
134.55.217.58
134.55.219.109
134.55.213.165
134.55.212.89
134.55.219.82
198.124.130.1
198.206.220.1
134.55.12.133
134.55.211.145
198.124.216.181
198.125.140.181
134.55.222.38
134.55.207.18
134.55.222.37
198.129.248.86
134.55.209.30
134.55.209.202
198.124.252.110
198.49.208.229
134.55.210.117
134.55.218.26
134.55.209.61
134.55.217.102
134.55.209.54
192.68.191.162
134.55.209.62
134.55.212.73
134.55.218.126
134.55.220.10
134.55.210.193
134.55.209.105
134.55.216.2
134.55.211.129
198.129.252.46
198.129.254.13
134.55.220.42
134.55.222.42
134.55.207.10
198.151.133.185
134.55.217.13
134.55.212.99
134.55.7.82
198.129.33.25
134.55.218.45
198.124.254.233
198.124.226.1
62.40.125.94
134.55.213.209
198.124.216.153
198.124.252.122
134.55.200.32
134.55.209.45
134.55.212.65
134.55.211.19
134.55.200.42
134.55.213.137
134.55.213.82
134.55.218.41
134.55.207.38
134.55.218.18
192.150.31.78
198.124.238.21
134.55.210.181
134.55.219.89
134.55.214.17
134.55.213.69
134.55.218.25
134.55.217.25
134.55.213.125
134.55.220.78
198.129.226.65
134.55.209.101
134.55.21.130
134.55.12.230
134.55.218.77
134.55.219.34
198.125.140.137
198.9.202.13
134.55.208.37
134.55.210.81
198.129.33.13
198.129.77.13
134.55.12.99
134.55.29.34
134.55.218.101
134.55.222.65
134.55.217.37
134.55.209.158
134.55.219.57
134.55.43.1
198.124.216.209
134.55.216.137
198.129.66.234
134.55.7.81
134.55.219.73
134.55.213.65
198.129.48.5
134.55.218.17
134.55.210.28
134.55.218.66
134.55.209.249
134.55.217.61
134.55.217.9
134.55.30.129
134.55.213.230
134.55.209.241
134.55.210.85
134.55.17.65
198.125.140.189
134.55.208.206
134.55.217.78
134.55.15.133
134.55.12.129
134.55.216.129
198.129.224.2
134.55.200.80
134.55.217.41
134.55.221.25
134.55.210.178
198.125.140.229
134.55.209.97
134.55.213.141
134.55.200.45
198.125.140.141
134.55.213.101
134.55.200.5
198.125.140.222
134.55.217.49
134.55.200.31
207.231.244.2
198.151.133.253
134.55.215.33
198.128.4.5
134.55.207.17
134.55.219.50
134.55.219.22
134.55.7.70
134.55.213.73
134.55.217.105
10.0.0.4
198.124.216.177
134.55.10.70
134.55.213.173
134.55.222.25
134.55.200.85
134.55.213.174
134.55.200.4
138.18.155.22
134.55.215.49
134.55.209.29
134.55.208.241
198.124.252.142
134.55.23.194
134.55.217.30
134.55.15.197
134.55.220.9
198.129.78.82
62.40.124.230
134.55.217.77
134.55.23.197
192.13.56.89
134.55.8.225
134.55.221.2
134.55.222.61
134.55.210.115
134.55.213.229
198.124.230.129
134.55.218.58
134.55.200.84
134.55.217.45
134.55.218.90
134.55.221.41
134.55.200.73
192.203.230.13
134.55.218.102
198.129.44.28
10.31.20.2
134.55.210.122
198.124.252.6
198.129.224.65
134.55.218.65
134.55.217.22
134.55.218.86
198.125.140.217
198.124.216.173
204.134.149.2
198.124.252.98
134.55.212.57
198.125.140.209
134.55.200.29
198.49.208.14
134.55.217.29
134.55.200.87
134.55.218.14
134.55.11.7
134.55.200.14
10.10.10.1
198.129.252.37
134.55.219.74
192.188.106.140
198.129.78.45
198.129.33.26
198.129.248.37
198.124.252.106
134.55.219.25
198.124.216.169
134.55.200.16
134.55.213.150
134.55.222.53
134.55.210.89
134.55.207.9
134.55.212.113
198.129.248.117
134.55.218.6
134.55.220.22
134.55.8.129
192.168.201.52
207.231.243.13
134.55.208.242
134.55.221.5
134.55.213.162
134.55.209.102
134.55.219.54
134.55.213.218
198.124.238.9
198.129.77.9
192.13.56.45
134.55.218.30
207.231.245.13
134.55.8.161
172.16.32.1
134.55.209.77
134.55.209.82
134.55.221.34
134.55.217.14
134.55.209.157
134.55.208.125
134.55.20.193
134.55.209.66
134.55.213.238
134.55.219.114
134.55.218.9
134.55.220.54
}}}

==== FCCN ====

{{{
193.136.5.3
193.137.1.161
193.136.1.189
193.136.249.142
193.136.252.3
193.137.0.42
193.137.1.245
194.210.30.1
193.137.0.145
193.136.1.38
193.137.0.43
193.137.0.4
193.136.1.41
193.136.5.4
193.137.1.213
193.136.249.110
193.136.249.78
193.136.5.9
193.136.5.2
194.210.63.253
193.136.4.161
193.136.249.46
193.136.1.177
193.136.255.254
193.136.249.14
193.137.1.169
193.137.59.113
193.137.0.18
193.137.4.17
193.137.0.153
193.137.0.11
193.136.252.2
193.136.1.37
193.137.0.30
193.136.4.26
193.137.0.2
193.136.1.222
193.136.255.252
193.136.249.174
193.136.1.221
62.40.124.186
193.136.5.1
193.136.5.6
}}}

==== GARR ====

{{{
193.206.134.238
193.206.141.98
193.206.134.190
193.206.136.126
193.206.134.65
193.206.134.218
193.206.143.125
193.206.134.13
193.206.134.210
193.206.141.109
193.206.141.49
193.206.131.221
193.206.134.182
193.206.134.142
193.206.141.62
193.206.134.69
193.206.141.34
193.206.131.249
193.206.141.14
193.206.131.250
193.206.141.6
193.206.134.246
193.206.143.254
193.206.136.125
193.206.134.26
193.206.140.253
193.206.143.252
193.206.141.53
193.206.134.106
193.206.141.22
193.206.134.34
193.206.134.21
193.206.134.114
193.206.131.222
193.206.141.10
193.206.134.121
193.206.136.61
193.206.134.214
193.206.137.254
193.206.134.74
193.206.141.33
193.206.141.102
193.206.141.101
193.206.134.194
193.206.134.118
193.206.140.254
193.206.134.66
193.206.134.193
193.206.134.33
193.206.134.41
193.206.141.5
193.206.143.126
193.206.128.252
193.206.141.9
193.206.141.61
193.206.134.53
193.206.141.89
193.206.134.62
193.206.134.101
193.206.134.89
193.206.134.22
193.206.134.54
193.206.134.213
193.206.141.105
193.206.142.254
193.206.140.190
193.206.141.25
193.206.132.188
193.206.134.105
193.206.134.78
193.206.141.17
193.206.134.198
193.206.143.188
193.206.142.190
193.206.134.61
193.206.134.234
193.206.134.14
193.206.134.6
193.206.137.62
193.206.129.2
193.206.143.122
193.206.134.10
193.206.134.233
193.206.134.25
193.206.134.181
193.206.134.137
193.206.141.90
193.206.134.5
193.206.141.57
193.206.134.209
10.1.2.3
193.206.134.217
193.206.141.65
193.206.141.18
193.206.132.252
193.206.141.21
193.206.134.38
193.206.143.190
193.206.134.90
193.206.141.110
193.206.134.250
193.206.134.253
193.206.131.252
193.206.134.113
193.206.134.141
193.206.134.230
193.206.132.61
193.206.136.253
193.206.134.9
193.206.134.97
193.206.134.98
193.206.134.45
193.206.137.126
193.206.141.30
193.206.140.126
193.206.130.252
193.206.134.237
193.206.134.229
193.206.134.122
193.206.134.222
193.206.143.253
193.206.134.249
193.206.141.29
193.206.134.154
193.206.134.225
193.206.129.3
193.206.134.221
193.206.134.42
193.206.134.205
193.206.134.73
193.206.134.158
193.206.129.4
193.206.134.245
193.206.134.46
193.206.141.26
193.206.141.54
193.206.137.61
193.206.134.153
193.206.134.226
193.206.134.117
193.206.134.206
193.206.134.77
193.206.143.121
193.206.134.254
193.206.136.189
193.206.136.190
193.206.141.106
193.206.141.13
193.206.141.50
193.206.134.109
193.206.134.157
193.206.141.66
193.206.141.97
193.206.134.197
193.206.134.37
193.206.132.125
193.206.134.138
193.206.134.70
193.206.134.110
193.206.134.189
193.206.137.190
193.206.134.102
193.206.141.58
}}}

==== Geant2 ====

{{{
62.40.114.49
150.99.188.202
62.40.125.17
62.40.112.37
62.40.114.56
62.40.124.177
62.40.114.18
62.40.112.25
62.40.125.77
216.24.184.86
62.40.114.48
62.40.112.42
62.40.114.20
62.40.114.8
62.40.112.46
62.40.124.229
62.40.124.253
62.40.124.221
62.40.114.3
62.40.114.42
62.40.112.41
62.40.114.13
128.0.0.6
198.32.11.51
62.40.114.36
62.40.114.53
62.40.124.97
62.40.112.70
62.40.114.5
62.40.124.249
}}}

==== Internet2 ====

{{{
64.57.28.56
211.79.48.158
198.32.11.21
192.122.183.10
208.100.127.33
198.125.140.230
64.57.18.33
205.213.119.14
10.254.254.4
138.18.155.34
64.57.17.129
64.57.28.244
64.57.29.61
64.57.16.193
207.231.240.131
192.122.183.46
64.57.29.13
198.32.11.105
64.57.18.209
192.35.86.226
64.57.28.248
216.249.136.198
64.57.23.81
192.91.246.125
64.57.28.24
198.32.11.97
64.208.110.190
192.88.192.138
198.49.182.7
205.189.32.117
64.57.28.161
192.122.183.30
64.57.18.97
137.164.26.133
64.208.110.26
131.247.47.213
64.57.17.209
64.57.18.81
64.57.29.45
74.125.48.106
64.57.29.17
206.196.177.106
62.40.125.18
149.165.254.3
199.18.156.242
192.88.115.117
64.57.18.249
199.18.156.246
192.35.86.230
64.57.28.45
80.231.134.30
64.57.28.11
64.57.18.17
207.231.242.131
207.210.142.2
64.57.16.213
198.32.10.190
205.189.32.97
207.231.242.8
64.57.23.97
164.113.238.193
205.189.32.93
64.57.17.213
64.57.29.25
192.150.29.6
64.57.28.241
64.57.23.73
64.57.18.113
198.49.182.5
64.57.18.241
208.77.76.130
198.32.11.65
144.92.233.117
198.86.17.66
64.57.29.57
198.32.11.80
216.27.100.54
64.57.28.129
64.57.28.243
192.84.8.254
192.31.99.134
208.100.127.37
137.227.2.182
198.32.173.194
149.165.254.7
64.57.17.85
64.57.28.4
64.57.23.105
131.247.47.225
64.57.18.201
64.57.28.7
64.57.16.97
198.32.11.41
64.57.27.254
64.57.18.225
198.124.194.10
207.231.246.131
64.57.28.15
192.5.89.222
203.181.248.141
205.213.118.10
64.208.110.198
198.9.202.205
192.41.213.113
64.57.29.69
64.57.28.43
64.57.28.25
64.215.195.42
64.57.16.225
64.57.23.1
207.231.243.131
205.213.119.10
64.57.24.254
140.173.1.238
64.57.16.129
128.135.247.125
64.57.17.81
64.57.18.1
205.213.119.30
64.57.28.12
64.57.28.39
64.57.28.33
206.220.240.86
74.125.48.226
204.238.76.6
198.32.11.69
198.32.11.50
64.57.28.44
64.57.28.5
198.32.177.189
64.57.23.89
64.57.23.113
64.57.28.53
64.57.28.40
204.238.76.2
64.57.29.22
64.57.19.21
198.32.153.205
64.57.16.1
64.57.29.20
64.57.17.65
64.57.17.193
64.57.29.5
64.57.16.89
200.0.207.10
198.32.180.67
117.103.111.153
200.23.60.122
64.57.28.26
64.57.28.16
64.57.17.33
149.165.254.23
207.231.241.8
64.57.28.18
216.27.100.62
207.231.240.8
64.57.16.21
69.31.111.90
198.32.165.194
64.57.23.65
64.57.29.65
206.223.119.120
198.32.11.45
164.113.238.142
64.57.28.247
134.75.108.46
209.131.107.142
64.57.28.37
64.57.28.47
143.215.193.10
64.57.25.254
64.57.18.233
198.109.37.22
64.57.16.65
192.35.86.174
207.231.241.131
64.57.18.65
72.36.127.138
198.32.8.83
64.57.28.38
64.57.29.37
198.124.216.158
149.165.254.21
199.109.4.154
64.57.23.49
74.200.187.5
64.57.18.193
64.57.28.61
150.99.199.94
64.57.28.246
10.254.254.9
64.57.29.53
208.77.76.138
150.99.200.194
64.57.28.65
207.72.112.38
198.32.11.13
64.57.17.1
64.57.28.57
64.57.19.17
64.57.28.13
64.57.18.185
64.57.16.17
64.57.26.254
198.32.154.6
64.57.16.161
64.57.29.29
141.225.250.30
64.57.23.121
192.168.1.1
64.57.28.245
141.225.250.26
192.88.192.134
64.57.23.33
64.57.28.177
138.18.47.34
64.57.28.249
64.57.17.25
64.57.29.41
64.57.29.33
64.57.16.33
211.79.48.178
64.208.110.38
198.9.201.205
64.57.17.145
198.32.170.43
64.57.28.17
198.32.14.65
199.18.156.134
207.231.243.8
64.57.17.21
64.57.23.41
207.72.112.34
64.57.28.10
64.57.28.20
64.57.17.17
198.86.53.2
10.254.254.6
64.57.29.49
198.32.11.101
216.249.136.134
206.196.178.46
198.32.11.85
64.57.28.42
64.57.28.242
64.57.29.9
64.57.16.209
205.213.118.6
64.57.28.27
192.17.10.46
192.245.196.110
198.32.118.55
64.57.18.49
64.57.17.225
64.57.28.6
205.213.119.26
138.18.47.42
192.35.86.9
64.57.28.14
156.110.203.2
207.231.245.8
64.57.17.149
198.32.154.133
137.164.26.129
198.32.176.89
198.32.165.66
64.57.28.19
198.32.252.254
199.109.11.2
156.110.203.6
199.18.156.130
64.57.18.129
64.57.28.36
64.57.17.97
64.57.19.1
64.208.110.186
74.125.48.178
198.32.11.29
198.32.11.109
64.57.28.46
64.57.18.217
192.88.115.25
}}}

==== Indianna Univesrity ====

{{{
149.165.227.252
149.165.128.5
149.165.254.225
192.12.206.185
149.165.254.33
149.165.184.6
149.165.254.2
149.165.254.142
149.165.254.54
199.8.220.5
149.165.254.249
149.165.254.22
149.165.227.249
72.36.127.150
192.5.40.179
192.5.40.187
149.165.254.121
149.165.254.81
149.165.254.25
149.165.254.4
149.165.254.89
149.165.128.6
149.165.254.70
149.165.184.130
149.165.254.30
149.165.255.65
149.165.184.1
149.165.227.254
199.8.220.65
149.165.254.74
198.49.182.129
149.165.254.41
149.165.254.58
149.165.255.64
192.12.206.181
192.12.206.225
149.165.254.9
149.165.184.134
149.165.254.245
149.165.254.6
72.12.193.22
149.165.184.3
149.165.254.45
149.165.184.8
149.165.254.50
149.165.254.20
149.159.254.125
199.8.220.1
149.165.183.13
192.12.206.209
149.165.254.237
149.165.129.254
149.165.254.77
149.165.254.13
149.165.184.9
149.165.254.233
199.8.220.73
192.5.40.166
149.165.184.5
149.165.254.37
144.228.154.166
149.165.254.101
149.165.183.17
149.165.254.229
149.165.184.7
192.5.40.134
149.165.254.113
10.10.10.4
149.165.254.134
72.12.215.250
149.165.128.4
149.165.254.29
149.165.227.21
149.165.254.26
149.165.184.4
207.72.112.50
149.165.184.2
72.12.215.254
149.165.254.240
}}}

==== PIONIER ====

{{{
212.191.224.58
212.191.224.130
212.191.126.4
150.254.255.5
212.191.224.70
150.254.255.10
150.254.162.229
212.191.224.186
212.191.224.42
212.191.224.174
212.191.224.38
212.191.224.82
212.191.224.6
212.191.224.50
62.40.124.182
212.191.224.166
212.191.224.18
212.191.224.206
212.191.224.74
212.191.224.106
212.191.224.234
212.191.224.178
212.191.224.90
212.191.224.162
212.191.224.66
212.191.224.170
212.191.224.238
}}}

==== SWITCH ====

{{{
130.59.36.210
130.59.36.250
192.65.184.221
130.59.36.145
130.59.36.90
130.59.36.1
130.59.37.121
130.59.15.14
130.59.36.9
130.59.32.58
130.59.36.109
130.59.36.2
130.59.37.65
130.59.36.57
130.59.32.42
130.59.37.29
130.59.37.18
130.59.32.151
213.248.79.190
130.59.37.142
130.59.36.157
130.59.36.50
130.59.32.160
130.59.32.158
130.59.36.81
130.59.36.106
130.59.37.33
130.59.32.35
130.59.32.60
130.59.36.170
130.59.37.14
130.59.36.49
130.59.36.185
130.59.37.98
130.59.36.58
130.59.36.197
130.59.36.181
130.59.36.85
130.59.36.94
130.59.36.42
130.59.37.30
130.59.37.13
130.59.36.153
130.59.36.214
62.40.124.82
130.59.36.234
130.59.36.102
130.59.32.8
130.59.36.66
130.59.36.158
130.59.36.22
130.59.36.237
130.59.37.82
130.59.37.38
130.59.36.162
130.59.36.46
130.59.37.1
130.59.37.37
130.59.32.11
130.59.32.54
130.59.36.166
130.59.36.113
130.59.36.6
130.59.36.126
130.59.36.173
130.59.37.130
130.59.32.157
130.59.32.14
130.59.36.174
130.59.36.178
130.59.37.90
130.59.32.55
130.59.37.66
130.59.36.193
130.59.37.117
130.59.32.161
130.59.36.117
130.59.36.98
130.59.37.70
130.59.37.41
130.59.32.152
130.59.32.47
130.59.36.217
130.59.36.65
192.65.184.84
130.59.36.129
130.59.36.89
62.40.124.22
130.59.37.105
130.59.37.34
130.59.36.137
130.59.32.51
130.59.37.85
130.59.37.133
130.59.37.109
130.59.37.93
130.59.36.73
130.59.37.22
130.59.36.249
130.59.36.69
130.59.36.45
130.59.37.78
130.59.37.45
130.59.37.102
130.59.36.34
130.59.37.81
130.59.36.21
64.213.33.222
130.59.36.26
130.59.36.53
130.59.32.48
130.59.37.49
130.59.37.2
130.59.36.206
130.59.37.74
130.59.36.194
130.59.36.218
130.59.32.162
130.59.36.110
130.59.36.70
130.59.36.222
130.59.32.56
130.59.37.110
130.59.36.77
130.59.32.12
130.59.36.17
130.59.37.86
130.59.36.118
130.59.36.161
130.59.32.61
130.59.36.209
130.59.32.28
130.59.32.156
130.59.36.245
130.59.32.59
130.59.36.62
130.59.37.53
194.242.34.53
130.59.36.150
130.59.32.153
130.59.36.198
192.65.184.173
130.59.36.238
130.59.36.130
130.59.37.26
130.59.36.177
130.59.36.142
130.59.36.74
130.59.36.33
130.59.37.17
130.59.32.30
130.59.15.15
130.59.36.205
130.59.36.146
130.59.37.101
130.59.36.122
130.59.37.77
130.59.37.42
130.59.37.46
130.59.36.202
130.59.36.221
130.59.36.78
130.59.36.165
130.59.36.97
130.59.37.73
130.59.36.105
130.59.37.50
130.59.36.169
192.65.185.130
130.59.32.57
130.59.36.54
130.59.36.242
130.59.15.13
130.59.36.125
130.59.37.106
130.59.36.18
130.59.37.89
130.59.36.61
130.59.37.21
130.59.32.52
130.59.37.25
130.59.37.97
130.59.36.154
130.59.36.101
130.59.36.5
130.59.32.154
130.59.36.13
130.59.36.213
130.59.32.159
130.59.32.10
130.59.36.182
130.59.36.138
194.242.34.52
130.59.37.129
130.59.36.86
130.59.36.93
130.59.36.226
130.59.36.149
130.59.36.201
64.212.70.62
213.242.73.138
130.59.36.121
130.59.37.94
130.59.36.82
130.59.37.69
130.59.32.53
130.59.36.246
130.59.36.241
129.143.29.42
130.59.32.155
130.59.36.41
130.59.36.114
130.59.36.141
194.42.48.11
}}}

=== Proposed Algorithm ===

The proposed algorithm works as follows.

Given a list of IP numbers, create a [http://en.wikipedia.org/wiki/Patricia_tree Patricia Tree] (or simply [http://en.wikipedia.org/wiki/Trie Trie]) and iterate over the list, inserting each IP number into the trie.  The trie data structure will automatically create inner nodes which correspond to the (candidate) summarization nodes, or CIDR classes.

When a node is created into the trie, two values are calculated and attached to the node:  the _coverage_ and the _childCount_.

The _childCount_ is the number of descendants below a node.  Or, in other words, the number of nodes within the subtrees deriving from that node.  Every time a node is added to the trie, its ancestors also have this value updated.

The _coverage_ is a measure of the density of number of desdendants of the node over the maximum possible number of hosts below the node.  The idea here is that, if below a node, there can exist a maximum of 32 hosts, but actually there exists only one, then the density of hosts below that node is low.  If there can exist a maximum of 32 hosts, and there are actually 32 hosts below the node, then the density is high (or maximal in this case).  The number of maximum hosts below a node is calculated as:

    `$self->{coverage} =  $self->{childCount} / (2**(MAX_KEY_LENGTH - $self->{mask}));`
	
where MAX_KEY_LENGTH is typically 32, the _mask_ is the CIDR class (number after the / in the IP number), and _childCount_ is the number of desdendants (calculated as above).  The meaning of this equation is:  MAX_KEY_LENGTH - _mask_ yields the number of bits available, in the range of IP addresses, to be assigned to hosts.  Raising 2 to this power results in the equivalent number of hosts available within this range of IP addresses.  Dividing the actual number of desdendants by the number of (maximum) available hosts yields the density, or coverage.  This coverage value is also updated as new nodes are added to the trie.

Once created, recurse down the trie, starting from the root node (the root node should be the looser, or larger, summarization IP number; in a worst case, it would be 0.0.0.0/0).  At each internal node, evaluate whether the trie should continue to be recursed down, or whether it should be pruned, and the corresponding node is then marked as a summarization node.  The decision of whether to mark a summarization node is done in the method _markIpTrie1_, shown below:


{{{
sub markIpTrie1 {
	my $self = shift;
	my ($summaryArrayListref, $node) = @_;
	
	my @summaryArrayList = @$summaryArrayListref;
	
	my $c0n = $node->{childZero};
	my $c1n = $node->{childOne};
		
		if(!(defined $c0n)) {
			
			$node->setSummaryMember();
			push(@summaryArrayList, $node);
		
		}elsif(defined $c0n &&
				($c0n->{mask} - $node->{mask} > 8) || 
				($c1n->{mask} - $node->{mask} > 8) || 
				($node->{coverage} < 0.000001) ) {
					
			@summaryArrayList = $self->markIpTrie1(\@summaryArrayList, $c0n);
			@summaryArrayList = $self->markIpTrie1(\@summaryArrayList, $c1n);
		}
		else {
			$node->setSummaryMember();
			push(@summaryArrayList, $node);
		}
		
		return @summaryArrayList;
	}
	
}}}

Basically, both children of a node are evaluated for the following conditions:

    _!ChildMask_ - _!NodeMask_ > 8

    _Node Coverage_ < 0.000001 (i.e., low density)

If either is satisfied, then the program will recurse down the subtrees below the current node and perform the same tests on the descendants.  If none of the conditions is satisfied, then the current node is marked as a summarization node and the subtrees below this node will not be further analyzed.

The heuristic used for this decision is based on the _distance_ between an internal node and its children, and the coverage or density.  The _distance_ value expresses the number of CIDR classes between the current node and its child; basically, it conveys the notion whether the current node represents a too large subnet to be considered for summarization.  For example, consider that the current node has a mask of 20 and its child has a mask of 32.  Then the current node represents a subclass of 4096 hosts (12 bits), so there's a possibility of having a substantial amount of nodes below the current node.  The algorithm then decides to recurse down the subtree.  Conversely, if the distance is short, then the current node may already comprise sufficient information to be selected as a summarization node.

The reasoning for the coverage or density tries to gather whether there exists already a relevant number of descendants for the current node; if there is, then it may be convenient to select the current node as a summarization node.

==== Subsequent Work ====

The algorithm is to be further optimized to allow for tuning of its heuristics, and to possibly incorporate the notion of weight of the subtrees.

The algorithm for [http://en.wikipedia.org/wiki/Cut_(graph_theory) Minimum Cut] might also be a candidate for the summarization issue, and shall be further investigated.


=== Proposed Implementation ===

Must be in Perl.  We will not be supporting the Java implementation directly.  The subsequent perl version can be translated by external programmers.

==== Class !IpTrie.pm ====

{{{
package IpTrie;

use strict;
use warnings;

use constant MAX_KEY_LENGTH => 32;

sub new {
	shift;
	my ( $t ) = @_;

	my $self = {};
	$self->{trie} = $t;
	$self->{nodeList} = ();
	$self->{root} = undef;
	
	bless($self);
	
	$self->updateNodelist();
	if ($self->{root}->{childCount} != $self->{trie}->getCount()) {
			print "Trie count != root IpTrieNode count";
			exit(-1);
	}
	
	return $self;
}

	
# this method walks the base Trie and fills in IpTrieNodes
sub updateNodelist {
	my $self = shift;
	$self->{nodeList} = ();
	my $startPosition = MAX_KEY_LENGTH;
	my $startKey = 0;
	$self->{root} = IpTrieNode->new($self->{trie}->getRootNode(), $startPosition, $startKey);
	push(@{$self->{nodeList}}, $self->{root});
	$self->walkTree($self->{root}, $startPosition, $startKey);
}
	
#walk the tree from node down
sub walkTree {
	my $self = shift;
	my ( $node, $position, $currentKey ) = @_;
		
	my $tnode = $node->{trieNode};
	my $c0 = $tnode->getChildZero();
	my $c1 = $tnode->getChildOne();
		
	if (defined $c0) {
    	my $c0Key = $c0->getKey() << ($position - $c0->getKeyLength());
    	my $c0Position = $position - $c0->getKeyLength();
    	$c0Key = $c0Key | $currentKey;
    	my $c0ipTrieNode = IpTrieNode->new($c0, $c0Position, $c0Key);
    	push(@{$self->{nodeList}}, $c0ipTrieNode);
    	$node->setChildZero($c0ipTrieNode);
    	$c0ipTrieNode->setParent($node);
    	$self->walkTree($c0ipTrieNode, $c0Position, $c0Key);

    }
    if ( defined $c1) {
    	my $c1Key = $c1->getKey() << ($position - $c1->getKeyLength());
    	my $c1Position = $position - $c1->getKeyLength();
    	$c1Key = $c1Key | $currentKey;
    	my $c1ipTrieNode = IpTrieNode->new($c1, $c1Position, $c1Key);
    	push(@{$self->{nodeList}}, $c1ipTrieNode);
    	$node->setChildOne($c1ipTrieNode);
    	$c1ipTrieNode->setParent($node);
    	$self->walkTree($c1ipTrieNode, $c1Position, $c1Key);
    }

}
	
sub getNodes {
	my $self = shift;
	return $self->{nodelist};
}
	
sub getInternalNodes {
	my $self = shift;
	my @alitn = ();
	for my $node ( @{$self->{nodelist}} ) {
		if (defined $node->{childZero}) {
			push(@alitn, $node);
		}
	}
	return @alitn;
}
	
sub getSummaryNodes {
	my $self = shift;
	my @alitn = ();
	
	for my $node ( @{$self->{nodelist}} ) {
			# evaluate what to return
			# here we say if the data pointer is null, but it 
			# has one child with data, then it is on the summary front
			
			# hackage for the root $node, which might have a null child
			# no other $node does
			next if (!(defined $node->{childOne} and defined $node->{childZero}));
			
			if (!(defined $node->{trieNode}->getData()) &&
				(defined $node->{childZero}->{trieNode}->getData() ||
				 defined $node->{childOne}->{trieNode}->getData()) ) {
					push(@alitn, $node);
			}
		}
		return @alitn;
}
	
sub getSummaryNodesSummaryFront {
	my $self = shift;
	my @alitn = ();
	
	for my $node ( @{$self->{nodelist}} ) {
			# evaluate what to return
			# here we say if the data pointer is null, but it 
			# has one child with data, then it is on the summary front
			
			# hackage for the root $node, which might have a null child
			# no other $node does
			next if (!(defined $node->{childOne} and defined $node->{childZero}));
			
			if (!(defined $node->{trieNode}->getData()) &&
				(defined $node->{childZero}->{trieNode}->getData() ||
				 defined $node->{childOne}->{trieNode}->getData() ) ) {
					push(@alitn, $node);
			}
		}
		
	my @alitn2 = ();
	for my $node ( @alitn ) {
			if( ($node->{mask} - $node->{parent}->{mask}) > 2) {
				push(@alitn2, $node);
			}
		}
		
		#sanity check
		my $sum = 0;
		for my $node ( @alitn2 ) {
			print $node->{addrString}." ".$node->{childCount};
			$sum += $node->{childCount};
		}
		
		if ($sum != $self->{trie}->getCount()) {
			print "sum, nodeCount ".$sum." ".$self->{trie}->getCount();
			print "Heuristic failed!";
			@alitn2 = ();
		}
		return @alitn2;
	}	
	
sub getSummary {
	my $self = shift;
		my @alitn = ();
		if (defined $self->{root}->{childZero}) {
			@alitn = $self->markIpTrie1(\@alitn, $self->{root}->{childZero});
		}
		if (defined $self->{root}->{childOne}) {
			@alitn = $self->markIpTrie1(\@alitn, $self->{root}->{childOne});
		}
		
		#sanity check
		my $sum = 0;
		for my $node ( @alitn ) {
			$sum += $node->{childCount};
			if ($node->{mask} == 32){ $sum++ };
		}
		
		if ($sum != $self->{trie}->getCount()) {
			print "Summarization failed! (covered ".$sum."prefixes out of ".$self->{trie}->getCount().")";
			@alitn = ();
		}
		
		return @alitn;
	}
	
	# this will walk the tree and evaluate whether to continue recursing down
	# the tree or add itself to the summary list and prune the subtree.
	# 
	# approach #1
	#
sub markIpTrie1 {
	my $self = shift;
	my ($summaryArrayListref, $node) = @_;
	
	my @summaryArrayList = @$summaryArrayListref;
	
	my $c0n = $node->{childZero};
	my $c1n = $node->{childOne};
		
		if(!(defined $c0n)) {
			
			$node->setSummaryMember();
			push(@summaryArrayList, $node);
		
		}elsif(defined $c0n &&
				($c0n->{mask} - $node->{mask} > 8) || 
				($c1n->{mask} - $node->{mask} > 8) || 
				($node->{coverage} < 0.000001) ) {
					
			@summaryArrayList = $self->markIpTrie1(\@summaryArrayList, $c0n);
			@summaryArrayList = $self->markIpTrie1(\@summaryArrayList, $c1n);
		}
		else {
			$node->setSummaryMember();
			push(@summaryArrayList, $node);
		}
		
		return @summaryArrayList;
	}

sub printDot {
	my $self = shift;
	my ($fileName) = @_;
	my $file;
	
	open ($file, "> ".$fileName) or die $!;

    print $file "digraph g {\n";
    $self->printDotNode($file, $self->{root});
    print $file "}\n";

    close $file;
}
	
sub printDotNode {
	my $self = shift;
	my ($file, $node) = @_;
		
	my $coverageString = sprintf("%.6f", $node->{coverage});
		
	my $nodeString = "\"".$node->{addrString}."\" [";
		
	if($node->{summaryMember}) {
			$nodeString .= "style=filled,fillcolor=lightslategray,";
		}
	elsif($node->{isInternal}) {
		$nodeString .= "style=filled,";
	}
		
	$nodeString .= "shape=record,label=\"<f0>".$node->{addrString}
		. "|<f1>" . $node->{childCount}
		. "|<f2>" . $coverageString
		. "\"]";
	print $file $nodeString."\n";
	
		if (defined $node->{childZero}) {
			my $edgeZeroString = "\"".$node->{addrString}."\" -> \""
			. $node->{childZero}->{addrString}."\"";
			$edgeZeroString .= "[label=".($node->{childZero}->{mask} - $node->{mask})."];";
			print $file $edgeZeroString."\n";
			$self->printDotNode($file, $node->{childZero});
		}
		
		if (defined $node->{childOne}) {
			my $edgeOneString = "\"".$node->{addrString}."\" -> \""
			. $node->{childOne}->{addrString}."\"";
			$edgeOneString .= "[label=".($node->{childOne}->{mask} - $node->{mask})."];";
			print $file $edgeOneString."\n";
			$self->printDotNode($file, $node->{childOne});
		}
	}

	1;
}}}  

==== Class !IpTrieNode.pm ====

{{{
package IpTrieNode;

use strict;
use warnings;

use constant MAX_KEY_LENGTH => 32;

sub longToIP {
	shift;
	my ($ipInLong) = @_;

    my $ipAddress = "";
    my @ipArrayInLong;
    my $num;

    for (my $i = 0; $i < 4; $i++) {

      my $factor = (256 ** (4 - $i - 1));
      $num = $ipInLong / $factor;
      $num =~ s/\.[0-9]*//;
      $ipInLong = $ipInLong - ($num * $factor);
      if ($num > 255) {
          print "Invalid CONVERSION";
      }
      
      $ipArrayInLong[$i] = $num;
           $ipAddress .= $ipArrayInLong[$i];
            if ($i != 3) {
                $ipAddress .= ".";
            }
        }
        return $ipAddress;
    }
    
sub new {
	shift;
	my ( $tnode, $position, $currentKey ) = @_;

	my $self = {};
	$self->{mask} = MAX_KEY_LENGTH - $position;
	$self->{ipAddress} = undef;
	$self->{key} = $currentKey;
	$self->{keyString} = IpTrieNode->longToIP($self->{key});
	$self->{addrString} = $self->{keyString}."/".$self->{mask};
	$self->{trieNode} = $tnode;
	$self->{parent} = undef;
	$self->{childZero} = undef;
	$self->{childOne} = undef;
	$self->{childCount} = $tnode->getChildCount();
	$self->{summaryMember} = 0;
	$self->{isInternal} = undef;
	$self->{coverage} = undef;

	if ($self->{mask} == MAX_KEY_LENGTH) { 
		$self->{coverage} = 1.0;
	}
	else {
			$self->{coverage} =  $self->{childCount} / (2**(MAX_KEY_LENGTH - $self->{mask}));
		}
		if(!(defined $tnode->getData())) {
			$self->{isInternal} = 1;
		}
		else {
			$self->{isInternal} = 0;
		}

	bless($self);
	return $self;
}

	
sub setSummaryMember {
	my $self = shift;
	$self->{summaryMember} = 1;	
}
	
sub isSummaryMember {
	my $self = shift;
	return $self->{summaryMember};
}
	
sub setParent {
	my $self = shift;
	my ($newParent) = @_;
	
	$self->{parent} = $newParent;
	return $self;
}
	
sub setChildZero {
	my $self = shift;
	my ($newChild) = @_;
	
	$self->{childZero} = $newChild;
	return $self;
}
	
sub setChildOne {
my $self = shift;
	my ($newChild) = @_;
	
	$self->{childOne} = $newChild;
	return $self;
}

1;
}}}

==== Class Trie.pm ====

{{{
package Trie;

use strict;
use warnings;

use constant MAX_KEY_LENGTH => 32;

    
sub new {
	shift;
	my ( $rootnode ) = @_;

	my $self = {};
	$self->{nodeCount} = undef;
	$self->{keyList} = ();
	$self->{rootNode} = $rootnode;

	bless($self);
	return $self;
}

sub getKeyList {
	my $self = shift;
    return $self->{keyList};
}

sub getRootNode {
	my $self = shift;
    return $self->{rootNode};
}
    
sub firstDigit {
	shift;
	my ( $key, $keyLength ) = @_;
	return ( $key >> ( $keyLength - 1 ) ) & 1;
}

sub Add {
	my $self = shift;
	my ( $key, $keyLength, $data ) = @_;
       
    $self->{nodeCount}++;
    $self->{rootNode}->incrementChildCount();
        
        if (Trie->firstDigit($key, $keyLength) == 1) {
            if (defined $self->{rootNode}->getChildOne()) {
                $self->{rootNode}->getChildOne()->Add($key, $keyLength, $data);
            }
            else {
                $self->{rootNode}->setChildOne(TrieNode->new($key, $keyLength));
                $self->{rootNode}->getChildOne()->setData($data);
            }
        } else {
            if (defined $self->{rootNode}->getChildZero()) {
                $self->{rootNode}->getChildZero()->Add($key, $keyLength, $data);
            }
            else {
                $self->{rootNode}->setChildZero(TrieNode->new($key, $keyLength));
                $self->{rootNode}->getChildZero()->setData($data);
            }
        }
        return $self;
    }

sub FindExactMatch {
	my $self = shift;
	my ( $key, $keyLength ) = @_;
	
        if (Trie->firstDigit($key, $keyLength) == 1){
        	if(defined $self->{rootNode}->getChildOne() 
            	&& $self->{rootNode}->getChildOne()->FindExactMatch($key, $keyLength)){
  				return 1;          		
            }else{
            	return 0;
            }
        }
        else{
            if(defined $self->{rootNode}->getChildZero() 
            	&& $self->{rootNode}->getChildZero()->FindExactMatch($key, $keyLength)){
  				return 1;          		
            }else{
            	return 0;
            }
        }
    }

sub Merge {
	my $self = shift;
	my ( $trie ) = @_;
	
    my @keys = $trie->GetKeys();
    for my $key (@keys){
            $self->Add($key, MAX_KEY_LENGTH, undef);
	}
        return $self;
}

sub GetKeys() {
	my $self = shift;
	
	unless(@_){
		#no parameters version
		my $key = 0;
        my $position = MAX_KEY_LENGTH;
        my @keys = ();

        if (defined $self->{rootNode}->getChildZero()){
            @keys = $self->GetKeys(\@keys, $self->{rootNode}->getChildZero(), $key, $position);
        }
        if (defined $self->{rootNode}->getChildOne()){
            @keys = $self->GetKeys(\@keys, $self->{rootNode}->getChildOne(), $key, $position);
        }
        return @keys;
	}
        
    #version with parameters
    my ($keysref, $node, $key, $position ) = @_;
    my @keys = @$keysref;
    
    $key = $key | ($node->getKey() << ($position - $node->getKeyLength()));

        if (defined $node->getChildZero()){
        	@keys = $self->GetKeys(\@keys, $node.getChildZero(), $key, $position - $node->getKeyLength());
        }
           
        if (defined $node->getChildOne()){
            @keys = $self->GetKeys(\@keys, $node.getChildOne(), $key, $position - $node->getKeyLength());
        }
        for (my $i = 0; $i < $node->getValueCount(); $i++) {
            push(@keys, $key);
        }
        return @keys;
    }

    #returns the best match of keys for the given inputs
sub FindBestMatch {
	my $self = shift;
	my ( $key, $keyLength ) = @_;
       
        #implements the best match by digging all the way to the leaf based on the $key difference.
        if (Trie->firstDigit($key, $keyLength) == 1) {
            if (defined $self->{rootNode}->getChildOne()){
                return $self->{rootNode}->getChildOne()->FindBestMatch($key, $keyLength);
            }
            else{
                return undef;
            }
        } elsif (!(defined $self->{rootNode}->getChildZero())){
        	return undef;
        }
        return $self->{rootNode}->getChildZero()->FindBestMatch($key, $keyLength);
    }

sub Equals {
	my $self = shift;
	my ( $trie ) = @_;
	
        if (defined $trie) {
            if ($self->getCount() == $trie->getCount()) {
                my @list1 = $self->GetKeys();
                my @list2 = $trie->GetKeys();

                for (my $i = 0; $i < $self->{nodeCount}; $i++) {
                    if (!($list1[$i] == $list2[$i])){
                        return 0;
                    }
                }
                return 1;
            }
        }
        return 0;
}

sub getCount {
	my $self = shift;
        return $self->{nodeCount};
    }

sub Remove {
	my $self = shift;
	
	#version with 2 parameters
	if($#_ == 2){
		my ( $key, $keyLength ) = @_;
    	my $root;

		if(Trie->firstDigit($key, $keyLength) == 1){
			$root = $self->{rootNode}->getChildOne();
		}else{
			$root =  $self->{rootNode}->getChildZero();
		}

   		if ($self->Remove($root, $key, $keyLength, 0)) {
            $self->{nodeCount}--;
            return 1;
        }
        return 0;
    }
    #version with 4 parameters
    else{
    	my ( $node, $key, $keyLength, $currentKeyLength ) = @_;
    	
    	my $success;
        my $child;

        $currentKeyLength += $node->getKeyLength();

        if ($currentKeyLength == $keyLength && $node->getKey() == ($key & 1)) {
            # by setting node.m_valueCount to -1, we indicate that it can be deleted
            if ($node->getValueCount() > 1){
                $node->setValueCount($node->getValueCount() - 1);
            }
            else {
                if (!(defined $node->getChildZero() or defined $node->getChildOne())){
                    $node->setValueCount($node->getValueCount() - 1);
                }else{
                    $node->setValueCount(0);
                }
            }
            return 1;
        } elsif (Trie->firstDigit($key, $keyLength - $currentKeyLength) == 1){
            $child = $node->getChildOne();
        } else {
            $child = $node->getChildZero();
        }

        $success = ((defined $child) && $self->Remove($child, $key, $keyLength, $currentKeyLength));

        if ($success) {
            # check if we need to delete nodes as we go back along the path
            # the node is safe to be deleted if its valueCount = -1

            if ($child->getValueCount() < 0) {
                if ($child->getKey() == 1){
                	$node->setChildOne(undef);
                }
                else{
                    $node->setChildZero(undef);
                }
                if ($node->getValueCount() == 0 && !(defined $node->getChildZero() or $node->getChildOne())){
                	$node->setValueCount(-1);
                }
            }
        }
        return $success;
    }
}

=cut

sub mostDominantKeyList {

        TrieNode childOne = $self->{rootNode}->getChildOne();
        TrieNode childZero = $self->{rootNode}->getChildZero();

        if (childOne != null) {
            mostDominantKeyList(childOne, childOne.getKey(), Constants.MAX_KEY_LENGTH);
        }
        if (childZero != null) {
            mostDominantKeyList(childZero, childZero.getKey(), Constants.MAX_KEY_LENGTH);
        }
    }

    private void mostDominantKeyList(TrieNode node, long $key, long position) {

        TrieNode childZero = $node->getChildZero();
        TrieNode childOne = $node->getChildOne();

        $key = $key | ($node->getKey() << (position - $node->getKeyLength()));
        position = position - $node->getKeyLength();
        if (childZero != null) {
            mostDominantKeyList(childZero, $key, position);
        }
        if (childOne != null) {
            mostDominantKeyList(childOne, $key, position);
        }
        if (($node->getChildOne() != null) && ($node->getChildZero() != null))
            keyList.add(TrieNode->new($key, position));
    }
    
sub printDot(String fileName) throws FileNotFoundException {
    	FileOutputStream file = new FileOutputStream(fileName);
    	PrintStream p = new PrintStream(file);
    	long position = Constants.MAX_KEY_LENGTH;
    	long currentKey = 0;
    	p.println("digraph g {");
    	$self->{rootNode}->printDotNode(p, rootNode, position, currentKey);
    	p.println("}");
    	p.close();
    }
    
sub<String> listInternalNodes() {
    	long position = Constants.MAX_KEY_LENGTH;
    	long currentKey = 0;
    	ArrayList<String> listOfNodes = new ArrayList<String>();
    	$self->{rootNode}->listInternalNodes(listOfNodes, position, currentKey);
    	return listOfNodes;
    }
    
sub<String> listSummaryNodes() {
    	long position = Constants.MAX_KEY_LENGTH;
    	long currentKey = 0;
    	ArrayList<String> listOfNodes = new ArrayList<String>();
    	$self->{rootNode}->listSummaryNodes(listOfNodes, position, currentKey);
    	return listOfNodes;
    }
}

=cut

1;
}}}

==== Class !TrieNode.pm ====

{{{
package TrieNode;

use strict;
use warnings;

sub new {
	shift;
	my ( $key, $keyLength, $valueCount ) = @_;

	my $self = {};
	$self->{key}       = $key;
	$self->{keyLength} = $keyLength;

	if ($valueCount) {
		$self->{valueCount} = $valueCount;
	}
	else {
		$self->{valueCount} = 1;
		$self->{childCount} = 0;
	}

	$self->{data}      = undef;
	$self->{childZero} = undef;
	$self->{childOne}  = undef;

	bless($self);
	return $self;
}

sub incrementChildCount {
	my $self = shift;
	$self->{childCount}++;
}

sub getChildCount {
	my $self = shift;
	return $self->{childCount};
}

sub getChildZero {
	my $self = shift;
	return $self->{childZero};
}

sub setChildZero {
	my $self = shift;
	if (@_) { $self->{childZero} = shift }
}

sub getChildOne {
	my $self = shift;
	return $self->{childOne};
}

sub setChildOne {
	my $self = shift;
	if (@_) { $self->{childOne} = shift }
}

sub getKey {
	my $self = shift;
	return $self->{key};
}

sub getKeyLength {
	my $self = shift;
	return $self->{keyLength};
}

sub firstDigit {
	shift;
	my ( $key, $keyLength ) = @_;
	return ( $key >> ( $keyLength - 1 ) ) & 1;
}

sub getCommonPart {
	shift;
	my ( $keyA, $keyLengthA, $keyB, $keyLengthB ) = @_;

	# truncate the keys so they are the same size (discard low bits)
	if ( $keyLengthA > $keyLengthB ) {
		$keyA >>= $keyLengthA - $keyLengthB;
		$keyLengthA = $keyLengthB;
	}
	else {
		$keyB >>= $keyLengthB - $keyLengthA;
	}

	my $diff  = $keyA ^ $keyB;
	my $count = 0;
	while ( $diff != 0 ) {
		$diff >>= 1;
		$count++;
	}

	my $keyCommon       = $keyA >> $count;
	my $keyLengthCommon = $keyLengthA - $count;

	return ( $keyCommon, $keyLengthCommon );
}

sub Equals {
	my $self = shift;
	my ($node) = @_;

	return $node
	  && ( $self->{key} == $node->{key}
		&& $self->{keyLength} == $node->{keyLength} );
}

sub isKey {
	my $self = shift;
	return $self->{valueCount} > 0;
}

sub getValueCount {
	my $self = shift;
	return $self->{valueCount};
}

sub setValueCount {
	my $self = shift;
	my ($value) = @_;

	if ( ref($value) == 'SCALAR' ) {
		$self->{valueCount} = $value;
	}
	else {
		$self->{data} = $value;
	}
}

sub getData {
	my $self = shift;
	return $self->{data};
}

sub setData {
	my $self = shift;
	if (@_) { $self->{data} = shift }
}

sub Add {
	my $self = shift;
	my ( $key, $keyLength, $data ) = @_;

	if ( $key == $self->{key} && $keyLength == $self->{keyLength} ) {
		$self->{valueCount}++;
	}
	else {
		my $keyDiff;
		my $keyLengthDiff;
		my $newNode;

		my @commonKeyAndKeyLength =
		  TrieNode->getCommonPart( $key, $keyLength, $self->{key}, $self->{keyLength} );

		my $keyCommon       = $commonKeyAndKeyLength[0];
		my $keyLengthCommon = $commonKeyAndKeyLength[1];

		$self->{childCount}++;

		$keyLengthDiff = $self->{keyLength} - $keyLengthCommon;
		$keyDiff       = $self->{key} - ( $keyCommon << $keyLengthDiff );

		if ( $keyLengthDiff > 0 ) {
			$newNode = TrieNode->new( $keyDiff, $keyLengthDiff );
			$newNode->{valueCount} = $self->{valueCount};
			$newNode->{childZero}  = $self->{childZero};
			$newNode->{childOne}   = $self->{childOne};
			$newNode->{data}       = $self->{data};
			$newNode->{childCount} = $self->{childCount} - 1;

			# update this node to hold common part
			$self->{key}        = $keyCommon;
			$self->{keyLength}  = $keyLengthCommon;
			$self->{valueCount} = 0;
			$self->{data}       = undef;

			# and set the new node as child of this node
			if ( TrieNode->firstDigit( $keyDiff, $keyLengthDiff ) == 1 ) {
				$self->{childZero} = undef;
				$self->{childOne}  = $newNode;
			}
			else {
				$self->{childZero} = $newNode;
				$self->{childOne}  = undef;
			}

			if (!(defined $newNode->{childOne} or defined $newNode->{childZero})) {
				$self->{childCount}++;
				if ( $newNode->{childCount} > 1 ) {
					print "confusion";
				}
				$newNode->{childCount} = 0;
			}
		}    

		# process diff with the new key, if any
		if ( $keyLength > $keyLengthCommon ) {

				# get diff with the new key
			$keyLengthDiff = $keyLength - $keyLengthCommon;
			$keyDiff       = $key - ( $keyCommon << $keyLengthDiff );
			
			if ( TrieNode->firstDigit( $keyDiff, $keyLengthDiff ) == 1 ) {
				if ( defined $self->{childOne} ) {
					$self->{childOne}->Add( $keyDiff, $keyLengthDiff, $data );
				}
				else {
					$self->{childOne} =  TrieNode->new( $keyDiff, $keyLengthDiff );
					$self->{childOne}->setData($data);
				}
			}
			else {
				if ( defined $self->{childZero} ) {
					$self->{childZero}->Add( $keyDiff, $keyLengthDiff, $data );
				}
				else {
					$self->{childZero} =  TrieNode->new( $keyDiff, $keyLengthDiff );
					$self->{childZero}->setData($data);
				}
			}
		}
		else {
			$self->{valueCount} = 1;

			#$self->{data} = $data; //XXX
		}
	}
	return $self;
}

sub FindExactMatch {
	my $self = shift;
	my ( $key, $keyLength ) = @_;

	my $matchStatus;
	my $keyCommon;
	my $keyLengthCommon;

	if ( $keyLength < $self->{keyLength} ) {
		$matchStatus = 0;
		return $matchStatus;
	}
	elsif ( $key == $self->{key} && $keyLength == $self->{keyLength} ) {
		$matchStatus = 1;
		return $matchStatus;
	}
	else {
		my @keyFields = TrieNode->getCommonPart( 
			$key, $keyLength, $self->{key}, $self->{keyLength} );
		
		$keyCommon       = $keyFields[0];
		$keyLengthCommon = $keyFields[1];
		my $keyLengthDiff = $keyLength - $keyLengthCommon;
		my $keyDiff       = $key - ( $keyCommon << $keyLengthDiff );
		if ( TrieNode->firstDigit( $keyDiff, $keyLengthDiff ) == 1 ) {
			if ( defined $self->{childOne} ){
			  return $self->{childOne}->FindExactMatch( $keyDiff, $keyLengthDiff );
			}else {
				$matchStatus = 0;
				return $matchStatus;
			}
		}
		else {
			if ( defined $self->{childZero} ){
			  return $self->{childZero}->FindExactMatch( $keyDiff, $keyLengthDiff );
			}else {
				$matchStatus = 0;
				return $matchStatus;
			}
		}
	}
}

sub FindBestMatch {
	my $self = shift;
	my ( $key, $keyLength ) = @_;

# note : we don't need to worry about a node being a terminator since at the end, we will either have
# - an exact match of the key, so the node will be a terminator
# - the last possible node on the path matching the key which can't be anything but a leaf, hence a terminator

	if ( $keyLength < $self->{keyLength}
		|| ( $key == $self->{key} && $keyLength == $self->{keyLength} ) ){
		
		return $self;
	}
	else {
		my @keyFields = TrieNode->getCommonPart( 
				$key, $keyLength, $self->{key}, $self->{keyLength} );
		
		my $keyCommon       = $keyFields[0];
		my $keyLengthCommon = $keyFields[1];

		my $keyLengthDiff = $keyLength - $keyLengthCommon;
		my $keyDiff       = $key - ( $keyCommon << $keyLengthDiff );

		if ( TrieNode->firstDigit( $keyDiff, $keyLengthDiff ) == 1 ) {
			if ( defined $self->{childOne} ) {
				return $self->{childOne}->FindBestMatch( $keyDiff, $keyLengthDiff );
			}
			else {
				return $self;
			}
		}
		else {
			if ( defined $self->{childZero} ) {
				return $self->{childZero}->FindBestMatch( $keyDiff, $keyLengthDiff );
			}
			else {
				return $self;
			}
		}
	}
}

sub Clone {
	my $self = shift;
	
	my $clone = TrieNode->new( $self->{key}, $self->{keyLength}, $self->{valueCount} );
	if ( defined $self->{childZero} ) {
		$clone->{childZero} = $self->{childZero}->Clone();
	}
	if ( defined $self->{childOne} ) {
		$clone->{childOne} = $self->{childOne}->Clone();
	}

	return $clone;
}


=cut

Not used?

sub printDotNode(TrieNode node, long position, long currentKey) {
    	TrieNode c0 = node.getChildZero();
    	TrieNode c1 = node.getChildOne();
    	long key = node.getKey();
    	long mask = Constants.MAX_KEY_LENGTH - position;
    	String keyString;
    	String addrString;
    	
    	if (key == -1) {
    		addrString = keyString = "\"" + "0.0.0.0/0" + "\"";
    		currentKey = 0;
    		p.println(addrString + " [shape=record,label=\"<f0>0.0.0.0/0|<f1>" 
    				+ node.getChildCount()
    				+ "\"];" + " // COUNT: " + node.getChildCount());
    	}
    	else {
    		key = currentKey;
    		keyString = helper.longToIP(key);
    		String unquotedAddrString = keyString + "/" + mask;
    		addrString = "\"" + keyString + "/" + mask + "\"";
    		if (node.getData() == null) {
    			//p.println(addrString + " [style=filled];" + " // COUNT: " + node.getChildCount());
    			p.println(addrString + " [style=filled,shape=record,label=\"<f0>" + unquotedAddrString
    					+ "|<f1>" + node.getChildCount() + "\"]"
    					+ "; // COUNT: " + node.getChildCount());
    		}
    		else {
    			//p.println(addrString + "; // COUNT: " + node.getChildCount());
    			p.println(addrString + " [shape=record,label=\"<f0>" + unquotedAddrString
    					+ "|<f1>" + node.getChildCount() + "\"]"
    					+ "; // COUNT: " + node.getChildCount());
    		}
    	}
    	
    	if (c0 != null) {
    		long c0Key = c0.getKey() << (position - c0.getKeyLength());
    		long c0Position = position - c0.getKeyLength();
    		long c0Mask = Constants.MAX_KEY_LENGTH - c0Position;
    		c0Key = c0Key | currentKey;
    		p.println(addrString + " -> \"" 
    				+ helper.longToIP(c0Key) + "/" + c0Mask
    				+ "\"" + "[label=" + (c0Mask - mask)  
    				+ "];" + "// kl: " + c0.getKeyLength() + " pos: " + position);
    		printDotNode(p, c0, c0Position, c0Key);	
    	}
    	if (c1 != null) {
    		long c1Key = c1.getKey() << (position - c1.getKeyLength());
    		long c1Position = position - c1.getKeyLength();
    		long c1Mask = Constants.MAX_KEY_LENGTH - c1Position;
    		c1Key = c1Key | currentKey;
    		p.println(addrString + " -> \"" 
    				+ helper.longToIP(c1Key) + "/" + c1Mask
    				+ "\"" + "[label=" + (c1Mask - mask)
    				+ "];"  + "// kl: " + c1.getKeyLength() + " pos: " + position);
    		printDotNode(p, c1, c1Position, c1Key);
    	}
    }
    
    public ArrayList<String> listInternalNodes(ArrayList<String> listOfNodes, long position, long currentKey) {
    	TrieNode c0 = $self->{getChildZero();
    	TrieNode c1 = $self->{getChildOne();
    	long key = $self->{getKey();
    	long mask = Constants.MAX_KEY_LENGTH - position;
    	String keyString;
    	String addrString;
    	TrieNode node = this;
    	
    	if (key == -1) {
    		addrString = keyString = "0.0.0.0/0";
    		currentKey = 0;
    	}
    	else {
    		key = currentKey;
    		keyString = helper.longToIP(key);
    		addrString = keyString + "/" + mask;
    		if (node.getData() == null) {
    			listOfNodes.add(addrString);
    		}
    	}
    	if (c0 != null) {
    		long c0Key = c0.getKey() << (position - c0.getKeyLength());
    		long c0Position = position - c0.getKeyLength();
    		//long c0Mask = Constants.MAX_KEY_LENGTH - c0Position;
    		c0Key = c0Key | currentKey;
    		c0.listInternalNodes(listOfNodes, c0Position, c0Key);
    	}
    	if (c1 != null) {
    		long c1Key = c1.getKey() << (position - c1.getKeyLength());
    		long c1Position = position - c1.getKeyLength();
    		//long c1Mask = Constants.MAX_KEY_LENGTH - c1Position;
    		c1Key = c1Key | currentKey;
    		c1.listInternalNodes(listOfNodes, c1Position, c1Key);
    	}

    	return listOfNodes;
    }
    
    /**
     * 
     * This method returns all the nodes which are necessary to summarize all inputs.
     * 
     * @param listOfNodes
     * @param position
     * @param currentKey
     * @return
     */
    public ArrayList<String> listSummaryNodes(ArrayList<String> listOfNodes, long position, long currentKey) {
    	TrieNode c0 = $self->{getChildZero();
    	TrieNode c1 = $self->{getChildOne();
    	long key = $self->{getKey();
    	long mask = Constants.MAX_KEY_LENGTH - position;
    	String keyString;
    	String addrString;
    	TrieNode node = this;
    	
    	if (key == -1) {
    		addrString = keyString = "0.0.0.0/0";
    		currentKey = 0;
    	}
    	else {
    		key = currentKey;
    		keyString = helper.longToIP(key);
    		addrString = keyString + "/" + mask;
    		if (node.getData() == null &&
    				 ( c0.getData() != null ||
    				c1.getData() != null )) {
    			listOfNodes.add(addrString);
    		}
    	}
    	if (c0 != null) {
    		long c0Key = c0.getKey() << (position - c0.getKeyLength());
    		long c0Position = position - c0.getKeyLength();
    		//long c0Mask = Constants.MAX_KEY_LENGTH - c0Position;
    		c0Key = c0Key | currentKey;
    		c0.listSummaryNodes(listOfNodes, c0Position, c0Key);
    	}
    	if (c1 != null) {
    		long c1Key = c1.getKey() << (position - c1.getKeyLength());
    		long c1Position = position - c1.getKeyLength();
    		//long c1Mask = Constants.MAX_KEY_LENGTH - c1Position;
    		c1Key = c1Key | currentKey;
    		c1.listSummaryNodes(listOfNodes, c1Position, c1Key);
    	}

    	return listOfNodes;
    }
}

=cut

1;
}}}

==== Test Script test.pl ====

This script tests the proposed implementation.  It should be executed as:

    `perl test.pl inputIPfile`

where _inputIPfile_ is a text file containing some IP numbers for which the summarization is to be calculated.  The script outputs two files:

    `inputIPfile_`-summary.txt_     and
    `inputIPfile_`-summary.dot_

where the _txt_ file contains the summarizing nodes, and the _dot_ file contains an input file to be used with [http://www.graphviz.org/ Graphviz] tool.

=== Experimentation Results ===

Three implementations are being initially tested on the test sets:  the original Perl code from Jason Zurawsky; the Java code from Martin Swany; and the new Perl code, as a direct translation of the Java code.

The results are below.

==== APAN ====

===== Original Perl =====

TBD (problems with requirements in package installation)

===== Java =====

Summarization nodes:

10.0.0.4/32
45.0.0.1/32
117.103.111.133/32
133.69.37.1/32
140.221.251.2/32
163.220.127.238/32
172.24.61.30/32
172.24.100.210/32
192.203.116.144/28
202.0.0.0/7

===== new Perl =====

Summarization nodes:

10.6e-005.0.0/32
45.1e-005.0.0/32
117.103.111.133/32
133.69.37.1/32
140.221.251.2/32
163.220.127.238/32
172.24.61.30/32
172.24.100.210/32
192.203.116.144/28
202.0.0.0/7

Comments:  bugs are noticeable in the first IP numbers.  The summarization nodes are the same as the Java code, nevertheless.

==== ESNET ====

===== Original Perl =====

TBD (problems with requirements in package installation)

===== Java =====

Summarization nodes:

10.0.0.4/32
10.10.10.1/32
10.31.20.2/32
18.201.0.118/32
62.40.124.230/32
62.40.125.64/27
117.103.111.157/32
128.0.0.0/4
147.155.254.1/32
150.99.198.218/32
150.99.199.62/32
172.16.32.0/30
192.0.0.0/5
204.134.149.2/32
207.231.240.0/20
211.79.48.173/32

===== new Perl =====

Summarization nodes:

10.6e-005.0.0/32
10.10.10.1/32
10.31.20.2/32
18.201.0.118/32
62.40.124.230/32
62.40.125.64/27
117.103.111.157/32
128.0.0.0/4
147.155.254.1/32
150.99.198.218/32
150.99.199.62/32
172.16.32.0/30
192.0.0.0/5
204.134.149.2/32
207.231.240.0/20
211.79.48.173/32

Comments:  bugs are noticeable in the first IP number.  The summarization nodes are the same as the Java code, nevertheless.

== Project Management ==

Most details TBD, basic outline:


|| _*Dates*_ || _*Task*_ || _*People*_ ||
|| Weekly || Conference Call - Discuss progress || Jason, Martin, Student (Jeff) || 
|| March 9th - 13th || Evaluate, Learn Current Alg - Identify Failure Points || Student (Martin, Jason) || 
|| March 16th - 20th || Propose Changes (in writing), Experiment on Hypothesis (in code), Publish Results (in writing) || Student (Martin, Jason) || 
|| March 23rd - 27th || Finalize Code in prototype, integration into gLS || Student, Jason (Martin) || 
|| March 30th - April 10th || Planet Lab Beta Testing - Construct Testbed? || Student, Brian T, Jason (Jeff, Martin) || 
|| Late April || Slack time, Member Meeting, Beta Release of New Code || All || 


=== Actions ===

 * JZ 
   * Gather Datasets - <font color=green>_*Done - 3/12*_</font>
   * Assist student in any and all tasks
   * gLS Integration
   * Final report on tasks
 * MS
   * Supervise student
   * weekly reports
   * Assist in researching proper algorithms
   * review progress of performance/effectiveness
 * Student
   * Review existing design of algorithm and source code - <font color=green>_*Done - 3/10*_</font>
   * Propose changes to algorithm - <font color=green>_*Done - 3/13*_</font>
   * Implement changes (several prototypes) in source code - <font color=red>_*IN PROGRESS - 3/xx*_</font>
   * Experimentation on data sets - <font color=red>_*IN PROGRESS - 3/xx*_</font>
   * Evaluation of results (correctness, speed, effectiveness)
   * Final source code review
   * Assist Jason in gLS integration
   * Assist Brian/Jason in test framework design, installation, testing
   * Final report on tasks
 * BT
   * Review current gLS design (April timeframe) 
   * Assist student in designing test framework
   * Assist student in framework deployment
   * review progress of performance/effectiveness
 * AB
   * Review current gLS design (April timeframe) 
   * Think about impact of topology in summarization
 * JB
   * review progress of performance/effectiveness
   * Review current gLS design (April timeframe) 
 * All
   * Review new algorithm (both effectiveness and performance) before gLS integration

 == Last Modified ==

$Id$