= DCN Interactions with the Lookup Service =

== TOC ==

 * [DCNLookupService#Architecture Architecture]
   * [DCNLookupService#Current Current]
   * [DCNLookupService#Proposed Proposed]
 * [DCNLookupService#Hostname_to_Link_URN_Mappings Hostname to Link URN Mappings]
   * [DCNLookupService#Current_Usage Current Usage]
     * [DCNLookupService#Insertion Insertion]
     * [DCNLookupService#Deletion Deletion]
     * [DCNLookupService#Query Query]
   * [DCNLookupService#Proposed_Usage Proposed Usage]
     * [DCNLookupService#New_Format New Format]
     * [DCNLookupService#Required_Changes Required Changes]
 * [DCNLookupService#Service_Registration Service Registration]
   * [DCNLookupService#IDC IDC]
   * [DCNLookupService#NB NB]

== Architecture == 

The _perfSONAR_ *gLS* is an extension of the original *LS*.  The original design paradigm was centered on offering services (data discovery/management) within a local setting.  Scalability to multi-domain operation can only be delivered through mechanisms that preserve this original design from the point of view of service and client applications.  The *gLS* architecture works with existing *LS* instances  to distribute the information into a larger _*gLS* cloud_ through the use of data summarization and propagation.  

=== Current === 

The following illustrates the legacy *LS* architecture from the point of view of both _perfSONAR_ and _DCN_ services.

http://perfsonar-ps.googlecode.com/svn/wiki/DCNLookupService/LS.png

The diagram illustrates some typical scenarios for this software:

 # Services register the presence of lokup data (e.g. the *MA* registers measurement data or the *DCN !WebAdmin* registers host to link mappings)
 # Services query for specific data (e.g. perfSONAR-UI is a client looking for specific measurement data from a given domain, the IDC is looking to translate a hostname to a linkid)

This centralized design has two clear benefits:

 # All services know the location of the *LS*
 # Information is guaranteed to be there if it is present in the framework
 
The downsides however are very prohibitive:

 # *LS* location is fixed
 # No redundancy
 # Performance bottleneck
 # Does not scale to the cases where individuals would like to run their own

The legacy *LS* is still available and supported as a product in the _perfSONAR_ framework, but all effort regarding this information service has been refocused to the *gLS*.

=== Proposed === 

The *gLS* architecture is similar to that of the *LS* where individual services still maintain the information of registered services and respond to queries.  The major difference is the existence of an _upper layer_ of *gLS* instances that propagate summarized information of each _lower level_ Home Lookup Service (*hLS*) into what has been termed the _*gLS* cloud_.  This cloud enables global discovery: the phase where before finding exactly what you want (e.g. data for idc.internet2.edu), you first find where it may live (e.g. the *hLS* for internet2.edu).

An example of the architecture follows.

http://perfsonar-ps.googlecode.com/svn/wiki/DCNLookupService/gLS.png

Similar to the *LS* design, there are only minor differences to consider:

 # There is not a central *LS* to contact where *ALL* data will live, but there is the *gLS cloud* that can be contacted from many points.
   * The *gLS* cloud is really a collection of _well known_ instances.  We use a bootstrapping method similar to DNS where a well known list is published.
   * Each *gLS* is synchronized; all data that is known to one *gLS* will be shared with the others.  This also enables hot backup of data and geographic redundancy.
   * Each *hLS* should register it's presence into the cloud, this can mean selecting one or many *gLS* instances to contact.
 # Query involves two steps now:
   * Discovery (e.g. who has data for a specific person)
   * Query (e.g. ask all that are returned from the first part if they have the data)

This diagram also illustrates some typical scenarios for the *gLS*:

 # Services register the presence of data to their *hLS* (e.g. the *MA* registers measurement data or the *DCN !WebAdmin* registers host to link mappings)
   * Note that this *hLS* can be configured, or the services _may_ use the *gLS* cloud to locate a close *hLS*.  This implementation detail is left up to the service.
 # Services query for specific data
   * The left-most IDC will query the *gLS cloud* first looking for information on some link.
   * The *gLS cloud* will reply back with a list of *hLS* instances that have reported they contain information that may match.
   * The IDC should then contact _each_ of the returned *hLS* values with the original query.  
   * A similar procedure is true for perfSONAR-UI
   
Some important things to note about the operation of *gLS* and *hLS* instances:

 # The perfSONAR Consortium (ESnet, Geant2, Internet2, RNP) will be maintaining a *gLS cloud* open for public use.
 # It is possible to set up other clouds: simply start a new *gLS* hints file and point people to use it.
 # DCN adopters can deploy their own *hLS* if desired.  The software will be packaged along with a copy of the !WebAdmin.
 # Internet2 will maintain (an) *hLS* instance(s) for our needs.  DCN software is welcome to continue treating the Internet2 instance as a _central_ *LS*.
 
== Hostname to Link URN Mappings == 

DCN software currently uses the *LS* to map hostnames (*friendly names*) to the usually non-friendly link urns.  This feature has two main parts:

 # A _!WebAdmin_ is used to register/delete the mappings (N.B.: Future plans may allow the IDC to do this)
 # The IDC/Client applications query to get the mappings/translate from one to the other.
 
The general idea of this operation will not change, although to support the *gLS* there will be minor format changes discussed below. 

=== Current Usage === 

A current non-production version of the DCN !WebAdmin can be found [https://dc211.internet2.edu/cgi-bin/dcn2.cgi here].  This is used to add and delete the link/host mappings to fit what is currently available in the DCN network.  Currently all DCN admins have access to this one interface on the only LS instance.  

==== Insertion ==== 

The !WebAdmin handles all insertions internally by using the perfSONAR-PS LS API.  An example registration message follows (note that this message is not seen by users of the !WebAdmin, but is included for context only):

{{{
<?xml version="1.0"?>
<nmwg:message xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" 
              xmlns:perfsonar="http://ggf.org/ns/nmwg/tools/org/perfsonar/1.0/" 
              xmlns:psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/" 
              type="LSRegisterRequest" id="message.9661208">
  
  <nmwg:metadata id="metadata.10027846">
    <perfsonar:subject xmlns:perfsonar="http://ggf.org/ns/nmwg/tools/org/perfsonar/1.0/">
      <psservice:service xmlns:psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/">
        <psservice:serviceName>DCN LS</psservice:serviceName>
        <psservice:accessPoint>http://localhost:9991/perfSONAR_PS/services/gLS</psservice:accessPoint>
        <psservice:serviceType>LS</psservice:serviceType>
      </psservice:service>
    </perfsonar:subject>
  </nmwg:metadata>
  
  <nmwg:data metadataIdRef="metadata.10027846" id="data.4327190">
    <nmtb:node xmlns:nmtb="http://ogf.org/schema/network/topology/base/20070828/" id="node.1">
      <nmtb:address type="hostname">test.internet2.edu</nmtb:address>
      <nmtb:relation type="connectionLink">
        <nmtb:linkIdRef>urn:ogf:network:domain=dcn.internet2.edu:node=BOS:port=8719:link=10.10.9.33</nmtb:linkIdRef>
      </nmtb:relation>
    </nmtb:node>
  </nmwg:data>

</nmwg:message>
}}}

The message identifies two parts:

 # The metadata including a _service_ subject
 # The data containing the actual link to host mapping.
 
The metadata contains a service.  This paradigm is a hold over from _perfSONAR_ where all framework pieces are in fact a part of a larger service oriented architecture.  It is anticipated in the future that the IDC or DC will be the _service_ for these mappings, but the current use is to simply impart some _fake_ meaning to keep the pattern the same.  The data must always contain the host to link mapping informatio, in the form of a node relation. 

==== Deletion ==== 

The !WebAdmin handles all deletions internally by using the perfSONAR-PS LS API. An example deletion message follows (note that this message is not seen by users of the !WebAdmin, but is included for context only): 

{{{
<?xml version="1.0"?>
<nmwg:message xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" 
              xmlns:perfsonar="http://ggf.org/ns/nmwg/tools/org/perfsonar/1.0/" 
              xmlns:psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/" 
              type="LSDeregisterRequest" id="message.9661208">
  
  <nmwg:metadata id="metadata.10027846">
    <nmwg:key id="k.10027846">
      <nmwg:parameters id="p.10027846">
        <nmwg:parameter name="lsKey">45bc4921351aedd712438194ae7e637e</nmwg:parameter>
      </nmwg:parameters>
    </nmwg:key>
  </nmwg:metadata>
  
  <nmwg:data metadataIdRef="metadata.10027846" id="data.4327190">
    <nmtb:node xmlns:nmtb="http://ogf.org/schema/network/topology/base/20070828/" id="node.1">
      <nmtb:address type="hostname">test.internet2.edu</nmtb:address>
      <nmtb:relation type="connectionLink">
        <nmtb:linkIdRef>urn:ogf:network:domain=dcn.internet2.edu:node=BOS:port=8719:link=10.10.9.33</nmtb:linkIdRef>
      </nmtb:relation>
    </nmtb:node>
  </nmwg:data>

</nmwg:message>
}}}

The major difference between this message and the [DCNLookupService#Insertion Insertion] message is the use of a _LSRegistration *Key*_.  This *key* is issued by an *LS* as a faster way to identify data, similar to a relational database.  

==== Query ==== 

The IDC currently uses a query to convert from hostname to link id, an example appears below:

{{{
<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" 
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
    <SOAP-ENV:Header/>
    <SOAP-ENV:Body>
        <nmwg:message type="LSQueryRequest" 
                      id="msg1" 
                      xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" 
                      xmlns:xquery="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/xquery/1.0/">
            <nmwg:metadata id="meta2">

                <!--hostname value gets replaced with the name to lookup -->

                <xquery:subject id="sub2">
                    declare namespace nmwg="http://ggf.org/ns/nmwg/base/2.0/";
                    declare namespace nmtb="http://ogf.org/schema/network/topology/base/20070828/";
                    /nmwg:store[@type="LSStore"]/nmwg:data/nmtb:node/nmtb:relation/nmtb:linkIdRef/text()[../../../nmtb:address[text()="<!--hostname-->"]]
                </xquery:subject>
                <nmwg:eventType>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/xquery/1.0</nmwg:eventType>
                <xquery:parameters id="param.1">
                <nmwg:parameter name="lsOutput">native</nmwg:parameter>
                 </xquery:parameters>
            </nmwg:metadata>
            <nmwg:data metadataIdRef="meta2" id="d2"/>
        </nmwg:message>
    </SOAP-ENV:Body>
</SOAP-ENV:Envelope> 
}}}


=== Proposed Usage === 

Building on the current scheme, there are two major changes to the current use of the *LS* by the DCN software:

 # [DCNLookupService#gLS_Integration gLS Integration]
 # [DCNLookupService#Data_Format Data Format]

*gLS* integration refers to the use of a two part query system to take advantage of information discovery available through the _*gLS* cloud_.  This interaction is best placed in an API, although it may be treated simply as a two message system similar to how the IDC currently opperates.  The data format is required take advantage of the data distribution mechanism that the *gLS* offers.  This is a minor format change and is explained in detail below.

==== gLS Integration ==== 

Each *gLS* is responsible for managing the summarized information of all *hLS* instances that choose to register.  The *hLS* instances will register a _summary_ (a condensed list of the data types, address ranges, and domains that correspond to _*their*_ registered information).  An example of the information propogation is pictured below:

http://perfsonar-ps.googlecode.com/svn/wiki/DCNLookupService/Info.png

In this example there are 3 _perfSONAR_ *MA* services, and a *DCN WebAdmin*.  Each is responsible for some amount of information; note that this information _may_ overlap.  Each service interacts with a nearby *hLS*.  This *hLS* has the task of periodically examining all registered information from the *MA* and *WebAdmin* and making a _summary_ of what is available.  This simply means condensing all available IP addresses into a _*CDIR*_ style and making note of both the data types (not pictured) and domains.  The *hLS* instances then register this information up a level into the _*gLS* cloud_.  This diagram only shows a single *gLS* in the _cloud_, so summarization is simple (combine the two summary sets from the *hLS* instances).  In this case no additional summarziation can be done (the IP ranges are as _tight_ as they can be right now).  

To take advantage of the _*gLS* cloud_ services must pose an initial query to any *gLS* instance that asks a less specific question e.g. instead of asking for a specific link or hostname, it is necessary to first ask *_where_* information on an IP range or domain will be present.  The *gLS* will respond with zero to many *hLS* instances that need to be contacted because they have the potential to posses information.  The _original_ query for a link/hostname may then be asked to all returned *hLS* instances to find the answer.  

In the above example, if an IDC where looking for _*host2.a.edu*_ so it can find a link, it must first look for where data for _*a.edu*_ may exist.  An even more specific query would be where _*OSCARS*_ data (the designation we are using for the host/link mappings) for _*a.edu*_ lives.  In the case of the 1st query the *gLS* will return that _*both*_ *hLS* instances would have data on *a.edu*, the 2nd query would only return the second *hLS*.  Once a list of *hLS* instances has been returned, the IDC can proceed as it has done in the past: send the query to translate _*host2.a.edu*_ into a link to all of the *hLS* instances.  

An example of the _warm up_ discovery query is pictured below:

{{{
<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" 
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
    <SOAP-ENV:Header/>
      <SOAP-ENV:Body>
        <nmwg:message type="LSQueryRequest" 
                      id="msg1" 
                      xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" 
                      xmlns:xquery="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/xquery/1.0/">

            <nmwg:metadata id="meta1">
                <xquery:subject id="sub1">

                  <!--domain value gets replaced with the name to lookup -->

  declare namespace nmwg="http://ggf.org/ns/nmwg/base/2.0/";
  declare namespace summary="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/summarization/2.0/";
  declare namespace perfsonar="http://ggf.org/ns/nmwg/tools/org/perfsonar/1.0/";
  declare namespace psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/";
  declare namespace nmtb="http://ogf.org/schema/network/topology/base/20070828/";
  for $metadata in /nmwg:store[@type="LSStore"]/nmwg:metadata
    let $metadata_id := $metadata/@id  
    let $data := /nmwg:store[@type="LSStore"]/nmwg:data[@metadataIdRef=$metadata_id]
    where $data/nmwg:metadata/nmwg:eventType[text()="http://oscars.es.net/OSCARS"] and $data/nmwg:metadata/summary:subject/nmtb:domain/nmtb:name[@type="dns" and text()="<!--domain-->"]
    return $metadata/perfsonar:subject/psservice:service/psservice:accessPoint

                </xquery:subject>
                <nmwg:eventType>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/xquery/1.0</nmwg:eventType>
                <xquery:parameters id="param1">
                    <nmwg:parameter name="lsOutput">native</nmwg:parameter>
                </xquery:parameters>
            </nmwg:metadata>
            
            <nmwg:data metadataIdRef="meta1" id="data1"/>

        </nmwg:message>
    </SOAP-ENV:Body>
</SOAP-ENV:Envelope> 
}}}

Alternatively, this query could be used (omitting the domain lookup portion):

{{{
<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" 
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
    <SOAP-ENV:Header/>
      <SOAP-ENV:Body>
        <nmwg:message type="LSQueryRequest" 
                      id="msg1" 
                      xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" 
                      xmlns:xquery="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/xquery/1.0/">

            <nmwg:metadata id="meta1">
                <xquery:subject id="sub1">

  declare namespace nmwg="http://ggf.org/ns/nmwg/base/2.0/";
  declare namespace summary="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/summarization/2.0/";
  declare namespace perfsonar="http://ggf.org/ns/nmwg/tools/org/perfsonar/1.0/";
  declare namespace psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/";
  declare namespace nmtb="http://ogf.org/schema/network/topology/base/20070828/";
  for $metadata in /nmwg:store[@type="LSStore"]/nmwg:metadata
    let $metadata_id := $metadata/@id  
    let $data := /nmwg:store[@type="LSStore"]/nmwg:data[@metadataIdRef=$metadata_id]
    where $data/nmwg:metadata/nmwg:eventType[text()="http://oscars.es.net/OSCARS"]
    return $metadata/perfsonar:subject/psservice:service/psservice:accessPoint

                </xquery:subject>
                <nmwg:eventType>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/xquery/1.0</nmwg:eventType>
                <xquery:parameters id="param1">
                    <nmwg:parameter name="lsOutput">native</nmwg:parameter>
                </xquery:parameters>
            </nmwg:metadata>
            
            <nmwg:data metadataIdRef="meta1" id="data1"/>

        </nmwg:message>
    </SOAP-ENV:Body>
</SOAP-ENV:Envelope> 
}}}

This would identify *hLS* instances that are known to have *DCN* data which can then be cached.  A _brute force_ approach would then be to update this cache periodically and always query these instances for the host/link mapping.

The output of either of these queries will be the following on success:

{{{
<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" 
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
    <SOAP-ENV:Header/>
    <SOAP-ENV:Body>
        <nmwg:message xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" 
                        messageIdRef="msg1" 
                        id="message.12474424" 
                        type="LSQueryResponse">
            <nmwg:metadata metadataIdRef="meta1" id="metadata.1620043">
                <nmwg:eventType>success.ls.query</nmwg:eventType>
            </nmwg:metadata>
            <nmwg:data metadataIdRef="metadata.1620043" id="data.15522751">
                <psservice:datum xmlns:psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/">
                    <psservice:accessPoint xmlns:psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/">http://localhost:9991/perfSONAR_PS/services/gLS</psservice:accessPoint>
                    <psservice:accessPoint xmlns:psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/">http://localhost:9992/perfSONAR_PS/services/gLS</psservice:accessPoint>
                </psservice:datum>
            </nmwg:data>
        </nmwg:message>
    </SOAP-ENV:Body>
</SOAP-ENV:Envelope> 
}}}

And the following on failure:

{{{
<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" 
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
    <SOAP-ENV:Header/>
    <SOAP-ENV:Body>
        <nmwg:message xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" 
                        messageIdRef="msg1" 
                        id="message.12474424" 
                        type="LSQueryResponse">
            <nmwg:metadata metadataIdRef="meta1" id="metadata.1620043">
                <nmwg:eventType>error.ls.query.empty_results</nmwg:eventType>
            </nmwg:metadata>
            <nmwg:data metadataIdRef="metadata.1620043" id="data.15522751">
                <nmwgr:datum xmlns:nmwgr="http://ggf.org/ns/nmwg/result/2.0/">Nothing returned for search.</nmwgr:datum>
            </nmwg:data>
        </nmwg:message>
    </SOAP-ENV:Body>
</SOAP-ENV:Envelope> 
}}}

==== Data Format ==== 

An example in the changes required to the format is below, in the context of a registration message:

{{{
<?xml version="1.0"?>
<nmwg:message xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" 
              xmlns:perfsonar="http://ggf.org/ns/nmwg/tools/org/perfsonar/1.0/" 
              xmlns:psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/" 
              xmlns:dcn="http://ggf.org/ns/nmwg/tools/dcn/2.0/"
              type="LSRegisterRequest" id="message.9661208">
  
  <nmwg:metadata id="metadata.10027846">
    <perfsonar:subject xmlns:perfsonar="http://ggf.org/ns/nmwg/tools/org/perfsonar/1.0/">
      <psservice:service xmlns:psservice="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/1.0/">
        <psservice:serviceName>DCN LS</psservice:serviceName>
        <psservice:accessPoint>http://localhost:9991/perfSONAR_PS/services/gLS</psservice:accessPoint>
        <psservice:serviceType>LS</psservice:serviceType>
      </psservice:service>
    </perfsonar:subject>
  </nmwg:metadata>
  
  <nmwg:data metadataIdRef="metadata.10027846" id="data.4327190">
    <nmwg:metadata xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" id="metadata.1">
      <dcn:subject xmlns:dcn="http://ggf.org/ns/nmwg/tools/dcn/2.0/" id="subject.1">
        <nmtb:node xmlns:nmtb="http://ogf.org/schema/network/topology/base/20070828/" id="node.1">
          <nmtb:address type="hostname">test.internet2.edu</nmtb:address>
          <nmtb:relation type="connectionLink">
            <nmtb:linkIdRef>urn:ogf:network:domain=dcn.internet2.edu:node=BOS:port=8719:link=10.10.9.33</nmtb:linkIdRef>
          </nmtb:relation>
        </nmtb:node>
      </dcn:subject>
      <nmwg:eventType>http://oscars.es.net/OSCARS</nmwg:eventType>
    </nmwg:metadata>
  </nmwg:data>

</nmwg:message>
}}}

The changes can be summarized as:

 # The node element can no longer be present directly in the data element.  For *gLS* interaction to be effective all registered information must follow the same pattern.  
 # There will now be a metadata element, this element will contain:
   # A DCN Subject.  This element will contain:
     # The node, it will remain unchanged.
   # An eventType.  This should contain some descriptive value for this type of 'data'.  Since these are connection mappings used by the IDC it should be the OSCARS namespace or perhaps the DCN/DICE protocol designation.  This can be left up to the DCN designers although once chosen it should remain consistent.
   # Parameters (optional and currently unused).
 # The metadata element will be placed into the data as before.

The modified query that the IDC would be required to make is pictured next (note the only changes are to the XPath expression):

{{{
<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" 
                   xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
    <SOAP-ENV:Header/>
    <SOAP-ENV:Body>
        <nmwg:message type="LSQueryRequest" 
                      id="msg1" 
                      xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" 
                      xmlns:xquery="http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/xquery/1.0/">
            <nmwg:metadata id="meta2">
                <!--hostname value gets replaced with the name to lookup -->

                <xquery:subject id="sub2">
                    declare namespace nmwg="http://ggf.org/ns/nmwg/base/2.0/";
                    declare namespace nmtb="http://ogf.org/schema/network/topology/base/20070828/";
                    /nmwg:store[@type="LSStore"]/nmwg:data/nmwg:metadata/*[local-name()='subject']/nmtb:node/nmtb:relation/nmtb:linkIdRef/text()[../../../nmtb:address[text()="<!--hostname-->"]]
                </xquery:subject>
                <nmwg:eventType>http://ggf.org/ns/nmwg/tools/org/perfsonar/service/lookup/xquery/1.0</nmwg:eventType>
                <xquery:parameters id="param.1">
                <nmwg:parameter name="lsOutput">native</nmwg:parameter>
                 </xquery:parameters>
            </nmwg:metadata>
            <nmwg:data metadataIdRef="meta2" id="d2"/>
        </nmwg:message>
    </SOAP-ENV:Body>
</SOAP-ENV:Envelope> 
}}}

==== Required Changes ==== 

With the migration of DCN to the upcoming 0.4 release, the logical time to implement the above changes is when everyone is upgrading.  The proposed plan with regards to *LS* software is:

 * Upload a patch for the _LSQuery_ used in the IDC for all legacy applications, the 0.4 release will include this
 * Cease operation of *packrat.internet2.edu:8005/perfSONAR_PS/services/LS* on a given flag day
 * Begin operations of a new LS instance TBD, the 0.4 release will come configured to use this value
 * Convert the IDC to use the *gLS cloud* as well as talk to any *hLS* and not just the centralized Internet2 instance
 * Provide instructions for DCN participants who wish to use their own *hLS*, but still make the Internet2 version available.
 
== Service Registration == 

This section is an internal work in progess, TBD really soon!

=== IDC === 

TBD

=== NB === 

TBD

== Last Updated ==

$Id$
